# 算法 第1章 基础

本书的目的是研究多种重要而实用的算法，即适合用计算机实现的解决问题的方法。和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。本章介绍的就是学习算法和数据结构所需要的基本工具。

首先要介绍的是基础编程模型。接下来重点介绍的是数据抽象并定义抽象数据类型（ADT）以进行模块化编程。接下来将学习三种基础的抽象数据类型：背包、队列和栈。1.3节用数组、变长数组和链表实现了背包、队列和栈的 API，它们是全书算法实现的起点和样板。**性能是算法研究的一个核心问题**。1.4节描述了分析算法性能的方法。我们的基本做法是科学式的，即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时重复这个过程。

### 算法

在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。算法是计算机科学的基础。是这个领域研究的核心。数据结构是算法的副产品或是结果，因此要理解算法必须学习数据结构。简单的算法也会产生复杂的数据结构，相应地，复杂的算法也许只需要简单的数据结构。

当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的不同并没有什么关系。但是**对于大型问题（或者是需要解决大量小型问题的应用），我们就需要设计能够有效利用时间和空间的方法了**


**学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任务。在某些需要处理上百万个对象的应用程序中，设计优良的算法甚至可以将程序运行的速度提高数百万倍。与此相反，花金钱和时间去购置新的硬件可能只能将速度提高十倍或是百倍。无论在任何应用领域，精心设计的算法都是解决大型问题最有效的方法**。

学习算法是非常有趣和令人激动的，因为这是一个历久弥新的领域。这个领域不断有新的发现，但研究透彻的算法仍然是少数。本书中既有精巧、复杂和高难度的算法，也有优雅、朴素和简单的算法。在科学和商业应用中，我们的目标是理解前者并熟悉后者，这样才能掌握这些有用的工具并学会算法式思考，以迎接未来计算任务的挑战。

### 1.1 基础编程模型

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模块**。

### 1.1.1 Java程序的基本结构

要创建静态方法库和定义数据类型，会用到下面五种语法，它们是 Java 语言的基础，也是大多数现代语言所共有的。

* **原始数据类型**:它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
* **语句**：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：声明、赋值、条件、循环、调用和返回。
* **数组**：数组是多个同种数据类型的值的集合。
* **静态方法**：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
* **字符串**：字符串是一连串的字符，Java 内置了对它们的一些操作。
* **标准输入/输出**：标准输入输出是程序与外界联系的桥梁。
* **数据抽象**：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。

#### Java程序及其命令行的调用

```
import java.util.Arrays;//导入一个java库
//代码文件名必须是 BinarySearch.java
public class BinarySearch
{
  //静态方法
  public static int rank(int key, int[] a)
  {
    int lo = 0;//初始化声明语句
    int hi = a.lenght - 1;
    while (lo <= hi)
    {
      int mid = lo + (hi - lo) / 2;
      if (key < a[mid]) hi = mid - 1;
      else if (key > a[mid]) lo = mid + 1;
      else return mid;
    }
    return -1;
  }
  
  public static void main(String[] args)
  {
    int[] whitelist = In.readInts(args[0]);
    Arrays.sort(whitelist);//调用Java库中的sort方法
    while (!StdIn.isEmpty())
    {
      //isEmpty方法和readInt方法：调用标准库中的方法
      int key = StdIn.readInt();
      if (rank(key, whitelist) == -1)
        StdOut.println(key);
    }
  }
}
```

### 1.1.2 原始数据类型与表达式

4种Java语言最基本的原始数据类型（Java语言内置的原始数据类型）：

* 整型（int），及其算术运算符；
* 浮点型（double），及其算术运算符；
* 布尔型（boolean），它的值 {true, false}及其逻辑操作；
* 字符型（char），它的值是你能够输入的英文字母数字字符和符号

![Java 程序的基本组成](https://upload-images.jianshu.io/upload_images/4164292-43a26749120c22aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对于原始类型来说，我们用标识符来引用变量，用+、-、* 、/ 等运算符来指定操作，用字面量，例如1或者3.14来表示值。

### 1.1.2.1 运算符优先级

运算符优先级：**运算符 * 和 /(以及%)的优先级高于 + 和 -（优先级越高，越早运算）；在逻辑运算符中，!拥有最高优先级，之后是 &&，接下来是 ||。一般来说，相同优先级的运算符的运算顺序是从左到右。与在正常的算数表达式中一样，使用括号能够改变这些规则**。

### 1.1.2.2 类型转换

如果不会损失信息，数值会被自动提升为高级的数据类型。例如，在表达式 1+2.5 中，1 会被转换为浮点数1.0，表达式的值也为double值3.5。转换指的是在表达式中把类型名放在括号里将其后的值转换为括号中的类型。例如，(int)3.7的值是3而(double)3的值是3.0。需要注意的是将浮点类型转换为整型将会截断小数部分而非四舍五入，在复杂的表达式中的类型转换可能会很复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。

### 1.1.2.3 比较

下列运算符能够比较相同数据类型的两个值并产生一个布尔值：相等（==）、不等（!=）、小于（<）、小于等于（<=）、大于（>）和大于等于（>=）。这些运算符被称为混合类型运算符，因为它们的结果是布尔型，而不是参与比较的数据类型。结果是布尔型的表达式被称为布尔表达式。我们将会看到这种表达式是条件语句和循环语句的重要组成部分。


### 1.1.2.4 其他五种原始类型

Java的整型能够表示 2<sup/>32</sup>个不同的值，用一个32位二进制即可表示（虽然现在的许多计算机有64位二进制，但整型仍然是32位）。与此相似，浮点型的标准规定为64位。这些大小对于一般应用程序中使用的整数和实数已经足够了。为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：

* 64位整数，及其算术运算符（long）；
* 16位整数，及其算术运算符（short）；
* 16位字符，及其算数运算符（char）；
* 8位整数，及其算术运算符（byte）；
* 32位单精度实数，及其算数运算符（float）；

### 1.1.3 语句

Java 程序是由语句组成的。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。

* 声明语句：创建某种类型的变量并用标识符为其命名。声明语句用来指定变量的名称和类型。Java是一种强类型的语言，所以 Java 编译器会检查类型的一致性（例如，它不会允许将布尔类型和浮点类型的变量相乘）。变量可以声明在第一次使用之前的任何地方。一般我们都在首次使用该变量时声明它。变量的作用域就是定义它的地方，一般由相同代码段中声明之后的所有语句组成。
* 赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。赋值语句的左侧必须是单个变量，右侧可以是能够得到相应类型的值的任意表达式。
* 条件语句：根据指定的条件执行两个代码段之一。比如 if语句
* 循环语句：只要条件为真就不断地反复执行代码段中的语句。比如 while语句
* 调用和返回语句：和静态方法有关，是改变执行流程和代码组织的另一种方式。比如Java 支持在 while 循环中使用 break语句和 continue 语句。break 语句表示立即从循环中退出；continue 语句表示立即结束本次循环并开始下一轮循环。

程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。一般来说代码的结构都是嵌套的：一个条件语句或循环语句的代码中也能包含条件语句或是循环语句。

### 1.1.4 简便记法

程序有很多中写法，我们追求清晰、优雅和高效的代码。这样的代码经常会使用以下这些广为流传的简便写法：

* 声明并初始化：可以将声明语句和赋值语句结合起来，在声明（创建）一个变量的同时将它初始化。最好在接近首次使用变量的地方声明它并将其初始化（为了限制它的作用域）。
* 隐式赋值：当希望一个变量的值相对于其当前值变化时，可以使用下面一些简便的写法。（1）递增/递减运算符：++i; 等价于 i=i+1;且表达式的值为 i+1;。类似地，--i;等价于 i=i-1; i++ 和 ++i 的不同在于 i++; 表达式的值为i。（2）其他复合运算符：i/=2;等价于 i=i/2; 注意，i += 1;等价于 i = i + 1;（以及 ++i;）。
* 单语句代码段：如果条件或循环语句的代码段只有一条语句，代码段的花括号可以省略。

![Java语句总结.png](https://upload-images.jianshu.io/upload_images/4164292-a0a41924d28e4ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.5 数组

数组能够**顺序存储相同类型的多个数据**。在 Java 代码中用 a[i]来访问数组a的第i个元素的值。在 Java 中这种数组被称为**一维数组**。

#### 1.1.5.1 创建并初始化数组

在 Java 程序中创建一个数组需要三步：
* (1)声明数组的名字和类型。在声明数组时，需要指定数组的名称和它含有的数据类型。 
* (2)创建数组。在创建数组时，需要指定数组的长度（元素的个数）。
* (3)初始化数组元素。

```
//(1)完整写法：
double[] a;//声明数组
a = new double[N];//创建数组
for (int i = 0; i < N; i++)
  a[i] = 0.0;//初始化数组
  
//(2)简化写法：
double[] a = new double[N];

//(3)声明初始化（声明、创建并初始化一个数组）：在编译时将数组初始化
int[] a = { 1, 1, 2, 3, 5, 8 };
```

【注意】我们需要在运行时明确地创建数组的原因是 Java 编译器在编译时无法知道应该为数组预留多少空间（对于原始类型则可以）。

#### 1.1.5.2 简化写法

为了精简代码，我们常常会利用 Java 对数组默认的初始化来将三个步骤合为一条语句。即：

```
double[] a = new double[N];
```

等号的左边声明了数组，等号的右边创建了数组。这种写法不需要for循环，因为在一个 Java 数组中 double 类型的变量的默认初始值都是0.0，但如果你想使用不同的初始值，那么就需要使用 for 循环了。数组类型的默认初始值是0，布尔型的默认初始值是 false。

#### 1.1.5.3 使用数组

在声明并创建数组之后，在代码的任何地方都能通过数组名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是固定的。程序能够通过 a.length 获取数组 a[] 的长度，而它的最后一个元素总是 a[a.length - 1]。Java会自动进行边界检查。如果你创建了一个大小为N的数组，但使用了一个小于0或者大于N-1 的索引访问它，程序会因为运行时抛出 ArrayOutOfBoundsException 异常而终止。

#### 典型的数组处理代码

* (1)找出数组a中最大的元素：

```
double max = a[0];
for (int i = 1; i < a.length; i++)
  if (a[i] > max) max = a[i];
```
* (2)计算数组元素的平均值：

```
int N = a.length;
double sum = 0.0;
for (int i = 0; i < N; i++)
  sum += a[i];
double average = sum / N;
```
* (3)复制数组：

```
int N = a.length;
double[] b = new double[N];
for (int i = 0; i < N; i++)
  b[i] = a[i];
```

* (4)颠倒数组元素的顺序：

```
int N = a.length;
for (int i = 0; i < N/2; i++)
{
  double temp = a[i];
  a[i] = a[N-1-i];
  a[N-i-1] = temp;
}
```

* (5)矩阵相乘（方阵）a[][] * b[][] = c[][]

```
int N = a.length;
double[][] c = new double[N][N];
for (int i = 0; i < N; i++)
  for (int j = 0; j < N; j++)
  {
    // 计算行 i 和列 j 的点乘
    for (int k = 0; k < N; k++)
      c[i][j] += a[i][k] * b[k][j];
  }
```

### 1.1.5.4 起别名

数组名表示的是整个数组，如果我们将一个数组变量赋值给另一个变量，那么两个变量将会指向同一个数组。

```
int[] a = new int[N];
...
a[i] = 1234;
int[] b = a;
...
b[i] = 5678;//a[i]的值也会变成 5678
```

上例中 a[i]的值也会变为 5678，这种情况叫做起别名，有时可能会导致难以觉察的问题。如果你是想将数组复制一份，那么应该声明、创建并初始化一个新的数组，然后将原数组中的元素值挨个复制到新数组。

### 1.1.5.5 二维数组

在 Java 中二维数组就是一维数组的数组。二维数组可以是参差不齐的（元素数组的长度可以不一致），但大多数情况下我们都会使用 M * N，即 M 行长度为 N 的数组的二维数组（也可以称数组含有N列）。在 Java 中访问二维数组 a[][] 的第 i 行第 j 列的元素可以写作 a[i][j]。声明二维数组需要两对方括号。创建二维数组时要在类型名之后分别在方括号中指定行数以及列数。

```
double[][] a = new double[M][N];
```

我们将这样的数组称为 M * N 的数组。我们约定，第一维是行数(M行)，第二维是列数(N列)。和一维数组一样，Java会将数值类型的数组元素初始化为0，将布尔型的数组元素初始化为false。默认的初始化对二维数组更有用，因为可以节约更多的代码。下面这段代码和刚才只用一行就完成创建和初始化的语句是等价的：

```
double[][] a;
a = new double[M][N];
for (int i = 0; i < M; i++)
  for (int j = 0; j < N; j++)
    a[i][j] = 0.0;
```

【注意】在将二维数组初始化为0时这段代码是多余的，但是如果想要初始化为其他值，我们就需要嵌套的 for 循环了。

### 1.1.6 静态方法

在许多语言中，静态方法被称为函数，因为它们和数学函数的性质类似。静态方法是一组在被调用时会被顺序执行的语句。修饰符 static 将这类方法和 1.2节中的实例方法区别开来。

#### 1.1.6.1 静态方法

方法封装了由一系列语句所描述的运算。方法需要参数并根据参数计算出某种数据类型的返回值或产生某种副作用（例如打印一个值）。每个静态方法都是由签名（关键字public static 以及函数的返回值，方法名以及一串各种类型的参数）和函数体（即包含在花括号中的代码）组成的。

![静态方法解析.png](https://upload-images.jianshu.io/upload_images/4164292-1cd5f255e5ddbc5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 典型静态方法的实现（绝对值、素数、平方根、三角形斜边、调和级数）

* 计算一个整数的绝对值：

```
public static int abs(int x)
{
  if (x < 0) return -x;
  else       return x;
}
```

* 计算一个浮点数的绝对值：

```
public static double abs(double x)
{
  if (x < 0.0) return -x;
  else         return x;
}
```

* 判定一个数是否是素数：

```
public static boolean isPrime(int N)
{
  if (N < 2) return false;
  for (int i = 2; i*i <= N; i++)
    if (N % i == 0) return false;
  return true;
}
```

* 计算平方根（牛顿迭代法）：

```
public static double sqrt(double c)
{
  if (c < 0) return Double.NaN;
  double err = le-15;
  double t = c;
  while (Math.abs(t - c/t) > err * t)
    t = (c/t + t) / 2.0;
  return t;
}
```

* 计算直角三角形的斜边：

```
public static double hypotenuse(double a, double b)
{
  return Math.sqrt(a*a + b*b);
}
```

* 计算调和级数：

```
public static double H(int N)
{
  double sum = 0.0;
  for (int i = 1; i <= N; i++)
    sum += 1.0 / i;
  return sum;
}
```

#### 1.1.6.2 调用静态方法

调用静态方法是写出方法名并在后面的括号中列出参数值，用逗号分隔。当调用是表达式的一部分时，方法的返回值将会替代表达式中的方法调用。例如，BinarySearch中调用 rank() 返回了一个int值。仅由一个方法调用和一个分号组成的语句一般用于产生副作用。例如，BinarySearch的 main() 函数中对系统方法 Arrays.sort()的调用产生的副作用，是将数组中的所有条目有序地排列。调用方法时，它的参数变量将被初始化为调用时所给出的相应表达式的值。返回语句将结束静态方法并将控制权交还给调用者。如果静态方法的目的是计算某个值，返回语句应该指定这个值（如果这样的静态方法在执行完所有的语句之后都没有返回语句，那么编译器会报错）。

#### 1.1.6.3 方法的性质

* 方法的参数按值传递
* 方法名可以被重载
* 方法只能返回一个值，但可以包含多个返回语句
* 方法可以产生副作用：方法的返回值可以是void，这表示该方法没有返回值。返回值为void的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回给调用方。

#### 1.1.6.4 递归

递归是指方法可以调用自己。使用递归可以使代码更简洁优雅、易懂。编写递归代码时最重要的有以下三点：

* 递归总有一个最简单的情况，方法的第一条语句总是一个包含return的条件语句
* 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。在下面的代码中，第四个参数和第三个参数的差值一直在缩小。
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。在下面的代码中，两个子问题各自操作的数组部分是不同的。

**二分查找的递归实现**

```
public static int rank(int key, int[] a)
{
  return rank(key, a, 0, a.length - 1);
}
public static int rank(int key, int[] a, int lo, int hi)
{
  //如果key存在于a[]中，它的索引不会小于lo且不会大于hi
  if (lo > hi) return -1;
  int mid = lo + (hi - lo) / 2;
  if (key < a[mid]) return rank(key, a, lo, mid - 1);
  else if (key > a[mid]) return rank(key, a, mid + 1, hi);
  else return mid;
}
```

违背其中任意一条都可能得到错误的结果或是低效的代码，而坚持这些原则能写出清晰、正确且容易评估性能的程序。使用递归的一个原因是递归代码比相应的非递归代码更加简洁优雅、易懂。另一个原因是我们可以使用数学模型来估计程序的性能。我们会在3.2节的二分查找以及其他几个地方分析这个问题。

#### 1.1.6.5 基础编程模型

静态方法库是定义在一个 Java 类中的一组静态方法。类的声明是public class 加上类名，以及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是.java。Java开发的基本模式是编写一个静态方法库（包含一个main()方法）来完成一个任务。输入 java 和类名以及一系列字符串就能调用类中的main()方法，其参数为由输入的字符串组成的一个数组。main()的最后一条语句执行完毕后程序终止。

#### 1.1.6.6 模块化编程

这个模型的最重要之处在于通过静态方法库实现了模块化编程。我们可以构造许多个静态方法库（模块），一个库中的静态方法也能够调用另一个库中的定义的静态方法。这能够带来许多好处：

* 程序整体的代码量很大时，每次处理的模块大小仍然适中；
* 可以共享和重用代码而无需重新实现；
* 很容易用改进的实现替换老的实现；
* 可以为解决编程问题建立合适的抽象模型；
* 缩小调试范围。

#### 1.1.6.7 单元化测试

Java编程的最佳实践之一就是每个静态方法库中都包含一个 main()函数来测试库中的所有方法（有些编程语言不支持多个main()方法，因此不支持这种方式）。恰当的单元测试本身也是很有挑战的编程任务。每个模块的main()方法至少应该调用模块中的其他代码并在某种程度上保证它的正确性。随着模块的成熟，我们可以将main()方法作为一个开发实例，在开发过程中用它来测试更多的细节；也可以把它编成一个测试用例来对所有代码进行全面的测试。当用例越来越复杂时，我们可能会将它独立成一个模块。

#### 1.1.6.8 外部库

* 系统标准库 java.lang.* ：这其中包括 Math 库，实现了常用的数学函数；Integer 和 Double 库，能够将字符串转化为 int 和 double 值；String 和 StringBuilder 库、System。
* 导入的系统库。例如java.utils.Arrays
* 其他库

要调用另一个库中的方法（存放在相同或指定的目录中，或是一个系统标准库，或是在类定义前用 import 语句导入的库），我们需要在方法前指定库的名称。例如，BinarySearch 的 main() 方法调用了系统库 java.utils.Arrays 的 sort() 方法，StdIn 库中的 readInts() 方法和 StdOut库中的 println() 方法。

### 1.1.7 API

#### 1.1.7.1 Java 数学函数库部分函数

![Java数学函数库部分函数.png](https://upload-images.jianshu.io/upload_images/4164292-d0d3ce83d581bd80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.7.2 Java 库

对于某些基础算法，可以自己实现，当然也可以使用高度优化的库直接调用。

#### 1.1.7.3 我们的标准库

为了介绍 Java 编程、为了科学计算以及算法的开发、学习和应用，我们也开发了若干库来提供一些实用的功能。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-d24f1d502327a00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

以上有些方法的实现非常简单，为什么还要再方法库中实现它们？设计良好的方法库对这个问题的标准回答如下：

* 这些方法所实现的抽象层有助于我们将精力集中在实现和测试本书中的算法，而非生成随机数或是统计计算。每次都自己写相同计算的代码，不如直接在用例中调用它们更简洁易懂。
* 方法库会经过大量测试，覆盖极端和罕见的情况，是我们可以信任的。这样的实现需要大量的代码。例如我们经常需要使用的各种数据类型的实现，又比如Java的 Array库针对不同数据类型对 sort() 进行了多次重载。

因此建议到本书的网站上去学习一下 STDRandom.java 和 StdStats.java 的源代码并好好利用这些经过验证了的实现。使用这些库最简单的方法就是从网站上下载它们的源代码并放入你的工作目录。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f36b2608e2e2d60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.7.4 你自己编写的库

你应该将自己编写的每一个程序都当做一个日后可以重用的库。

* 编写用例，在实现中将计算过程分解成可控的部分。
* 明确静态方法库和与之对应的 API（或者多个库的多个API）
* 实现 API 和一个能够对方法进行独立测试的 main() 函数。

API 的目的是将调用和实现分离：除了API中给出的信息，调用者不需要知道实现的其他细节，而实现也不应考虑特殊的应用场景。API使我们能够广泛地重用那些为各种目的独立开发的代码。相应地，程序员也可以将 API 看作调用和实现之间的一份契约，它详细说明了每个方法的作用。

### 1.1.8 字符串

String 类型是 Java 的一个数据类型，但并不是原始数据类型。

#### 1.1.8.1 字符串拼接

Java 内置了一个串联 String 类型字符串的运算符（+）。

#### 1.1.8.2 类型转换

![image.png](https://upload-images.jianshu.io/upload_images/4164292-01dad084429bdcea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.8.3 自动转换

我们很少明确使用 toString()方法，因为 Java在连接字符串时会自动将任意数据类型的值转换为字符串：如果加号（+）的一个参数是字符串，那么Java会自动将其他参数转换为字符串。除了像“The square root of 2.0 is” + Math.sqrt(2.0)这样的使用方式之外，这种机制也使我们能够通过一个空字符串 "" 将任意数据类型的值转换为字符串值。

#### 1.1.8.4 命令行参数

在 Java 中字符串的一个重要的用途就是使程序能够接收到从命令行传递过来的信息。这种机制很简单。**当你输入命令 java和一个库名以及一系列字符串之后，Java 系统会调用库的main()方法并将那一系列字符串变成一个数组作为参数传递给它。例如，BinarySearch的main()方法需要一个命令行参数，因此系统会创建一个大小为1的数组。程序用这个值，也就是 args[0]，来获取白名单文件的文件名并将其作为 StdIn.readInts() 的参数。另一种在我们的代码中常用的用法是当命令行参数表示的是数字时，我们会用 parseInt() 和 parseDouble() 方法将其分别转换为整数和浮点数**。

### 1.1.9 输入输出

#### 1.1.9.1 命令和参数

终端窗口包含一个提示符，通过它我们能够向操作系统输入命令和参数。我们会经常使用 java 命令来运行我们的程序。Java 类都会包含一个静态方法 main()，它有一个 String 数组类型的参数 args[]。这个数组的内容就是我们输入的命令行参数，操作系统会将它传递给 java。Java和操作系统都默认参数为字符串。如果我们需要的某个参数是数字，我们会使用类似 Integer.parseInt() 的方法将其转换为适当的数据类型的值。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-fb46a261be3ffc84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)






















