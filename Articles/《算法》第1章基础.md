# 算法 第1章 基础

本书的目的是研究多种重要而实用的算法，即适合用计算机实现的解决问题的方法。和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。本章介绍的就是学习算法和数据结构所需要的基本工具。

首先要介绍的是基础编程模型。接下来重点介绍的是数据抽象并定义抽象数据类型（ADT）以进行模块化编程。接下来将学习三种基础的抽象数据类型：背包、队列和栈。1.3节用数组、变长数组和链表实现了背包、队列和栈的 API，它们是全书算法实现的起点和样板。**性能是算法研究的一个核心问题**。1.4节描述了分析算法性能的方法。我们的基本做法是科学式的，即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时重复这个过程。

### 算法

在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。算法是计算机科学的基础。是这个领域研究的核心。数据结构是算法的副产品或是结果，因此要理解算法必须学习数据结构。简单的算法也会产生复杂的数据结构，相应地，复杂的算法也许只需要简单的数据结构。

当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的不同并没有什么关系。但是**对于大型问题（或者是需要解决大量小型问题的应用），我们就需要设计能够有效利用时间和空间的方法了**


**学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任务。在某些需要处理上百万个对象的应用程序中，设计优良的算法甚至可以将程序运行的速度提高数百万倍。与此相反，花金钱和时间去购置新的硬件可能只能将速度提高十倍或是百倍。无论在任何应用领域，精心设计的算法都是解决大型问题最有效的方法**。

学习算法是非常有趣和令人激动的，因为这是一个历久弥新的领域。这个领域不断有新的发现，但研究透彻的算法仍然是少数。本书中既有精巧、复杂和高难度的算法，也有优雅、朴素和简单的算法。在科学和商业应用中，我们的目标是理解前者并熟悉后者，这样才能掌握这些有用的工具并学会算法式思考，以迎接未来计算任务的挑战。

### 1.1 基础编程模型

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模块**。

### 1.1.1 Java程序的基本结构

要创建静态方法库和定义数据类型，会用到下面五种语法，它们是 Java 语言的基础，也是大多数现代语言所共有的。

* **原始数据类型**:它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
* **语句**：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：声明、赋值、条件、循环、调用和返回。
* **数组**：数组是多个同种数据类型的值的集合。
* **静态方法**：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
* **字符串**：字符串是一连串的字符，Java 内置了对它们的一些操作。
* **标准输入/输出**：标准输入输出是程序与外界联系的桥梁。
* **数据抽象**：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。

#### Java程序及其命令行的调用

```
import java.util.Arrays;//导入一个java库
//代码文件名必须是 BinarySearch.java
public class BinarySearch
{
  //静态方法
  public static int rank(int key, int[] a)
  {
    int lo = 0;//初始化声明语句
    int hi = a.lenght - 1;
    while (lo <= hi)
    {
      int mid = lo + (hi - lo) / 2;
      if (key < a[mid]) hi = mid - 1;
      else if (key > a[mid]) lo = mid + 1;
      else return mid;
    }
    return -1;
  }
  
  public static void main(String[] args)
  {
    int[] whitelist = In.readInts(args[0]);
    Arrays.sort(whitelist);//调用Java库中的sort方法
    while (!StdIn.isEmpty())
    {
      //isEmpty方法和readInt方法：调用标准库中的方法
      int key = StdIn.readInt();
      if (rank(key, whitelist) == -1)
        StdOut.println(key);
    }
  }
}
```

### 1.1.2 原始数据类型与表达式

4种Java语言最基本的原始数据类型（Java语言内置的原始数据类型）：

* 整型（int），及其算术运算符；
* 浮点型（double），及其算术运算符；
* 布尔型（boolean），它的值 {true, false}及其逻辑操作；
* 字符型（char），它的值是你能够输入的英文字母数字字符和符号

![Java 程序的基本组成](https://upload-images.jianshu.io/upload_images/4164292-43a26749120c22aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对于原始类型来说，我们用标识符来引用变量，用+、-、* 、/ 等运算符来指定操作，用字面量，例如1或者3.14来表示值。

### 1.1.2.1 运算符优先级

运算符优先级：**运算符 * 和 /(以及%)的优先级高于 + 和 -（优先级越高，越早运算）；在逻辑运算符中，!拥有最高优先级，之后是 &&，接下来是 ||。一般来说，相同优先级的运算符的运算顺序是从左到右。与在正常的算数表达式中一样，使用括号能够改变这些规则**。

### 1.1.2.2 类型转换

如果不会损失信息，数值会被自动提升为高级的数据类型。例如，在表达式 1+2.5 中，1 会被转换为浮点数1.0，表达式的值也为double值3.5。转换指的是在表达式中把类型名放在括号里将其后的值转换为括号中的类型。例如，(int)3.7的值是3而(double)3的值是3.0。需要注意的是将浮点类型转换为整型将会截断小数部分而非四舍五入，在复杂的表达式中的类型转换可能会很复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。

### 1.1.2.3 比较

下列运算符能够比较相同数据类型的两个值并产生一个布尔值：相等（==）、不等（!=）、小于（<）、小于等于（<=）、大于（>）和大于等于（>=）。这些运算符被称为混合类型运算符，因为它们的结果是布尔型，而不是参与比较的数据类型。结果是布尔型的表达式被称为布尔表达式。我们将会看到这种表达式是条件语句和循环语句的重要组成部分。


### 1.1.2.4 其他五种原始类型

Java的整型能够表示 2<sup/>32</sup>个不同的值，用一个32位二进制即可表示（虽然现在的许多计算机有64位二进制，但整型仍然是32位）。与此相似，浮点型的标准规定为64位。这些大小对于一般应用程序中使用的整数和实数已经足够了。为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：

* 64位整数，及其算术运算符（long）；
* 16位整数，及其算术运算符（short）；
* 16位字符，及其算数运算符（char）；
* 8位整数，及其算术运算符（byte）；
* 32位单精度实数，及其算数运算符（float）；

### 1.1.3 语句

Java 程序是由语句组成的。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。

* 声明语句：创建某种类型的变量并用标识符为其命名。声明语句用来指定变量的名称和类型。Java是一种强类型的语言，所以 Java 编译器会检查类型的一致性（例如，它不会允许将布尔类型和浮点类型的变量相乘）。变量可以声明在第一次使用之前的任何地方。一般我们都在首次使用该变量时声明它。变量的作用域就是定义它的地方，一般由相同代码段中声明之后的所有语句组成。
* 赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。赋值语句的左侧必须是单个变量，右侧可以是能够得到相应类型的值的任意表达式。
* 条件语句：根据指定的条件执行两个代码段之一。比如 if语句
* 循环语句：只要条件为真就不断地反复执行代码段中的语句。比如 while语句
* 调用和返回语句：和静态方法有关，是改变执行流程和代码组织的另一种方式。比如Java 支持在 while 循环中使用 break语句和 continue 语句。break 语句表示立即从循环中退出；continue 语句表示立即结束本次循环并开始下一轮循环。

程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。一般来说代码的结构都是嵌套的：一个条件语句或循环语句的代码中也能包含条件语句或是循环语句。

### 1.1.4 简便记法

程序有很多中写法，我们追求清晰、优雅和高效的代码。这样的代码经常会使用以下这些广为流传的简便写法：

* 声明并初始化：可以将声明语句和赋值语句结合起来，在声明（创建）一个变量的同时将它初始化。最好在接近首次使用变量的地方声明它并将其初始化（为了限制它的作用域）。
* 隐式赋值：当希望一个变量的值相对于其当前值变化时，可以使用下面一些简便的写法。（1）递增/递减运算符：++i; 等价于 i=i+1;且表达式的值为 i+1;。类似地，--i;等价于 i=i-1; i++ 和 ++i 的不同在于 i++; 表达式的值为i。（2）其他复合运算符：i/=2;等价于 i=i/2; 注意，i += 1;等价于 i = i + 1;（以及 ++i;）。
* 单语句代码段：如果条件或循环语句的代码段只有一条语句，代码段的花括号可以省略。

![Java语句总结.png](https://upload-images.jianshu.io/upload_images/4164292-a0a41924d28e4ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.5 数组

数组能够**顺序存储相同类型的多个数据**。在 Java 代码中用 a[i]来访问数组a的第i个元素的值。在 Java 中这种数组被称为**一维数组**。

#### 1.1.5.1 创建并初始化数组

在 Java 程序中创建一个数组需要三步：
* (1)声明数组的名字和类型。在声明数组时，需要指定数组的名称和它含有的数据类型。 
* (2)创建数组。在创建数组时，需要指定数组的长度（元素的个数）。
* (3)初始化数组元素。

```
//(1)完整写法：
double[] a;//声明数组
a = new double[N];//创建数组
for (int i = 0; i < N; i++)
  a[i] = 0.0;//初始化数组
  
//(2)简化写法：
double[] a = new double[N];

//(3)声明初始化（声明、创建并初始化一个数组）：在编译时将数组初始化
int[] a = { 1, 1, 2, 3, 5, 8 };
```

【注意】我们需要在运行时明确地创建数组的原因是 Java 编译器在编译时无法知道应该为数组预留多少空间（对于原始类型则可以）。

#### 1.1.5.2 简化写法

为了精简代码，我们常常会利用 Java 对数组默认的初始化来将三个步骤合为一条语句。即：

```
double[] a = new double[N];
```

等号的左边声明了数组，等号的右边创建了数组。这种写法不需要for循环，因为在一个 Java 数组中 double 类型的变量的默认初始值都是0.0，但如果你想使用不同的初始值，那么就需要使用 for 循环了。数组类型的默认初始值是0，布尔型的默认初始值是 false。

#### 1.1.5.3 使用数组

在声明并创建数组之后，在代码的任何地方都能通过数组名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是固定的。程序能够通过 a.length 获取数组 a[] 的长度，而它的最后一个元素总是 a[a.length - 1]。Java会自动进行边界检查。如果你创建了一个大小为N的数组，但使用了一个小于0或者大于N-1 的索引访问它，程序会因为运行时抛出 ArrayOutOfBoundsException 异常而终止。

#### 典型的数组处理代码

* (1)找出数组a中最大的元素：

```
double max = a[0];
for (int i = 1; i < a.length; i++)
  if (a[i] > max) max = a[i];
```
* (2)计算数组元素的平均值：

```
int N = a.length;
double sum = 0.0;
for (int i = 0; i < N; i++)
  sum += a[i];
double average = sum / N;
```
* (3)复制数组：

```
int N = a.length;
double[] b = new double[N];
for (int i = 0; i < N; i++)
  b[i] = a[i];
```

* (4)颠倒数组元素的顺序：

```
int N = a.length;
for (int i = 0; i < N/2; i++)
{
  double temp = a[i];
  a[i] = a[N-1-i];
  a[N-i-1] = temp;
}
```

* (5)矩阵相乘（方阵）a[][] * b[][] = c[][]

```
int N = a.length;
double[][] c = new double[N][N];
for (int i = 0; i < N; i++)
  for (int j = 0; j < N; j++)
  {
    // 计算行 i 和列 j 的点乘
    for (int k = 0; k < N; k++)
      c[i][j] += a[i][k] * b[k][j];
  }
```

### 1.1.5.4 起别名

数组名表示的是整个数组，如果我们将一个数组变量赋值给另一个变量，那么两个变量将会指向同一个数组。

```
int[] a = new int[N];
...
a[i] = 1234;
int[] b = a;
...
b[i] = 5678;//a[i]的值也会变成 5678
```

上例中 a[i]的值也会变为 5678，这种情况叫做起别名，有时可能会导致难以觉察的问题。如果你是想将数组复制一份，那么应该声明、创建并初始化一个新的数组，然后将原数组中的元素值挨个复制到新数组。

### 1.1.5.5 二维数组

在 Java 中二维数组就是一维数组的数组。二维数组可以是参差不齐的（元素数组的长度可以不一致），但大多数情况下我们都会使用 M * N，即 M 行长度为 N 的数组的二维数组（也可以称数组含有N列）。在 Java 中访问二维数组 a[][] 的第 i 行第 j 列的元素可以写作 a[i][j]。声明二维数组需要两对方括号。创建二维数组时要在类型名之后分别在方括号中指定行数以及列数。

```
double[][] a = new double[M][N];
```

我们将这样的数组称为 M * N 的数组。我们约定，第一维是行数(M行)，第二维是列数(N列)。和一维数组一样，Java会将数值类型的数组元素初始化为0，将布尔型的数组元素初始化为false。默认的初始化对二维数组更有用，因为可以节约更多的代码。下面这段代码和刚才只用一行就完成创建和初始化的语句是等价的：

```
double[][] a;
a = new double[M][N];
for (int i = 0; i < M; i++)
  for (int j = 0; j < N; j++)
    a[i][j] = 0.0;
```

【注意】在将二维数组初始化为0时这段代码是多余的，但是如果想要初始化为其他值，我们就需要嵌套的 for 循环了。

### 1.1.6 静态方法

在许多语言中，静态方法被称为函数，因为它们和数学函数的性质类似。静态方法是一组在被调用时会被顺序执行的语句。修饰符 static 将这类方法和 1.2节中的实例方法区别开来。

#### 1.1.6.1 静态方法

方法封装了由一系列语句所描述的运算。方法需要参数并根据参数计算出某种数据类型的返回值或产生某种副作用（例如打印一个值）。每个静态方法都是由签名（关键字public static 以及函数的返回值，方法名以及一串各种类型的参数）和函数体（即包含在花括号中的代码）组成的。

![静态方法解析.png](https://upload-images.jianshu.io/upload_images/4164292-1cd5f255e5ddbc5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 典型静态方法的实现（绝对值、素数、平方根、三角形斜边、调和级数）

* 计算一个整数的绝对值：

```
public static int abs(int x)
{
  if (x < 0) return -x;
  else       return x;
}
```

* 计算一个浮点数的绝对值：

```
public static double abs(double x)
{
  if (x < 0.0) return -x;
  else         return x;
}
```

* 判定一个数是否是素数：

```
public static boolean isPrime(int N)
{
  if (N < 2) return false;
  for (int i = 2; i*i <= N; i++)
    if (N % i == 0) return false;
  return true;
}
```

* 计算平方根（牛顿迭代法）：

```
public static double sqrt(double c)
{
  if (c < 0) return Double.NaN;
  double err = le-15;
  double t = c;
  while (Math.abs(t - c/t) > err * t)
    t = (c/t + t) / 2.0;
  return t;
}
```

* 计算直角三角形的斜边：

```
public static double hypotenuse(double a, double b)
{
  return Math.sqrt(a*a + b*b);
}
```

* 计算调和级数：

```
public static double H(int N)
{
  double sum = 0.0;
  for (int i = 1; i <= N; i++)
    sum += 1.0 / i;
  return sum;
}
```

#### 1.1.6.2 调用静态方法

调用静态方法是写出方法名并在后面的括号中列出参数值，用逗号分隔。当调用是表达式的一部分时，方法的返回值将会替代表达式中的方法调用。例如，BinarySearch中调用 rank() 返回了一个int值。仅由一个方法调用和一个分号组成的语句一般用于产生副作用。例如，BinarySearch的 main() 函数中对系统方法 Arrays.sort()的调用产生的副作用，是将数组中的所有条目有序地排列。调用方法时，它的参数变量将被初始化为调用时所给出的相应表达式的值。返回语句将结束静态方法并将控制权交还给调用者。如果静态方法的目的是计算某个值，返回语句应该指定这个值（如果这样的静态方法在执行完所有的语句之后都没有返回语句，那么编译器会报错）。

#### 1.1.6.3 方法的性质

* 方法的参数按值传递
* 方法名可以被重载
* 方法只能返回一个值，但可以包含多个返回语句
* 方法可以产生副作用：方法的返回值可以是void，这表示该方法没有返回值。返回值为void的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回给调用方。

#### 1.1.6.4 递归

递归是指方法可以调用自己。使用递归可以使代码更简洁优雅、易懂。编写递归代码时最重要的有以下三点：

* 递归总有一个最简单的情况，方法的第一条语句总是一个包含return的条件语句
* 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。在下面的代码中，第四个参数和第三个参数的差值一直在缩小。
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。在下面的代码中，两个子问题各自操作的数组部分是不同的。

**二分查找的递归实现**

```
public static int rank(int key, int[] a)
{
  return rank(key, a, 0, a.length - 1);
}
public static int rank(int key, int[] a, int lo, int hi)
{
  //如果key存在于a[]中，它的索引不会小于lo且不会大于hi
  if (lo > hi) return -1;
  int mid = lo + (hi - lo) / 2;
  if (key < a[mid]) return rank(key, a, lo, mid - 1);
  else if (key > a[mid]) return rank(key, a, mid + 1, hi);
  else return mid;
}
```

违背其中任意一条都可能得到错误的结果或是低效的代码，而坚持这些原则能写出清晰、正确且容易评估性能的程序。使用递归的一个原因是递归代码比相应的非递归代码更加简洁优雅、易懂。另一个原因是我们可以使用数学模型来估计程序的性能。我们会在3.2节的二分查找以及其他几个地方分析这个问题。

#### 1.1.6.5 基础编程模型

静态方法库是定义在一个 Java 类中的一组静态方法。类的声明是public class 加上类名，以及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是.java。Java开发的基本模式是编写一个静态方法库（包含一个main()方法）来完成一个任务。输入 java 和类名以及一系列字符串就能调用类中的main()方法，其参数为由输入的字符串组成的一个数组。main()的最后一条语句执行完毕后程序终止。

#### 1.1.6.6 模块化编程

这个模型的最重要之处在于通过静态方法库实现了模块化编程。我们可以构造许多个静态方法库（模块），一个库中的静态方法也能够调用另一个库中的定义的静态方法。这能够带来许多好处：

* 程序整体的代码量很大时，每次处理的模块大小仍然适中；
* 可以共享和重用代码而无需重新实现；
* 很容易用改进的实现替换老的实现；
* 可以为解决编程问题建立合适的抽象模型；
* 缩小调试范围。

#### 1.1.6.7 单元化测试

Java编程的最佳实践之一就是每个静态方法库中都包含一个 main()函数来测试库中的所有方法（有些编程语言不支持多个main()方法，因此不支持这种方式）。恰当的单元测试本身也是很有挑战的编程任务。每个模块的main()方法至少应该调用模块中的其他代码并在某种程度上保证它的正确性。随着模块的成熟，我们可以将main()方法作为一个开发实例，在开发过程中用它来测试更多的细节；也可以把它编成一个测试用例来对所有代码进行全面的测试。当用例越来越复杂时，我们可能会将它独立成一个模块。

#### 1.1.6.8 外部库

* 系统标准库 java.lang.* ：这其中包括 Math 库，实现了常用的数学函数；Integer 和 Double 库，能够将字符串转化为 int 和 double 值；String 和 StringBuilder 库、System。
* 导入的系统库。例如java.utils.Arrays
* 其他库

要调用另一个库中的方法（存放在相同或指定的目录中，或是一个系统标准库，或是在类定义前用 import 语句导入的库），我们需要在方法前指定库的名称。例如，BinarySearch 的 main() 方法调用了系统库 java.utils.Arrays 的 sort() 方法，StdIn 库中的 readInts() 方法和 StdOut库中的 println() 方法。

### 1.1.7 API

#### 1.1.7.1 Java 数学函数库部分函数

![Java数学函数库部分函数.png](https://upload-images.jianshu.io/upload_images/4164292-d0d3ce83d581bd80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.7.2 Java 库

对于某些基础算法，可以自己实现，当然也可以使用高度优化的库直接调用。

#### 1.1.7.3 我们的标准库

为了介绍 Java 编程、为了科学计算以及算法的开发、学习和应用，我们也开发了若干库来提供一些实用的功能。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-d24f1d502327a00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

以上有些方法的实现非常简单，为什么还要再方法库中实现它们？设计良好的方法库对这个问题的标准回答如下：

* 这些方法所实现的抽象层有助于我们将精力集中在实现和测试本书中的算法，而非生成随机数或是统计计算。每次都自己写相同计算的代码，不如直接在用例中调用它们更简洁易懂。
* 方法库会经过大量测试，覆盖极端和罕见的情况，是我们可以信任的。这样的实现需要大量的代码。例如我们经常需要使用的各种数据类型的实现，又比如Java的 Array库针对不同数据类型对 sort() 进行了多次重载。

因此建议到本书的网站上去学习一下 STDRandom.java 和 StdStats.java 的源代码并好好利用这些经过验证了的实现。使用这些库最简单的方法就是从网站上下载它们的源代码并放入你的工作目录。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f36b2608e2e2d60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.7.4 你自己编写的库

你应该将自己编写的每一个程序都当做一个日后可以重用的库。

* 编写用例，在实现中将计算过程分解成可控的部分。
* 明确静态方法库和与之对应的 API（或者多个库的多个API）
* 实现 API 和一个能够对方法进行独立测试的 main() 函数。

API 的目的是将调用和实现分离：除了API中给出的信息，调用者不需要知道实现的其他细节，而实现也不应考虑特殊的应用场景。API使我们能够广泛地重用那些为各种目的独立开发的代码。相应地，程序员也可以将 API 看作调用和实现之间的一份契约，它详细说明了每个方法的作用。

### 1.1.8 字符串

String 类型是 Java 的一个数据类型，但并不是原始数据类型。

#### 1.1.8.1 字符串拼接

Java 内置了一个串联 String 类型字符串的运算符（+）。

#### 1.1.8.2 类型转换

![image.png](https://upload-images.jianshu.io/upload_images/4164292-01dad084429bdcea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.8.3 自动转换

我们很少明确使用 toString()方法，因为 Java在连接字符串时会自动将任意数据类型的值转换为字符串：如果加号（+）的一个参数是字符串，那么Java会自动将其他参数转换为字符串。除了像“The square root of 2.0 is” + Math.sqrt(2.0)这样的使用方式之外，这种机制也使我们能够通过一个空字符串 "" 将任意数据类型的值转换为字符串值。

#### 1.1.8.4 命令行参数

在 Java 中字符串的一个重要的用途就是使程序能够接收到从命令行传递过来的信息。这种机制很简单。**当你输入命令 java和一个库名以及一系列字符串之后，Java 系统会调用库的main()方法并将那一系列字符串变成一个数组作为参数传递给它。例如，BinarySearch的main()方法需要一个命令行参数，因此系统会创建一个大小为1的数组。程序用这个值，也就是 args[0]，来获取白名单文件的文件名并将其作为 StdIn.readInts() 的参数。另一种在我们的代码中常用的用法是当命令行参数表示的是数字时，我们会用 parseInt() 和 parseDouble() 方法将其分别转换为整数和浮点数**。

### 1.1.9 输入输出

#### 1.1.9.1 命令和参数

终端窗口包含一个提示符，通过它我们能够向操作系统输入命令和参数。我们会经常使用 java 命令来运行我们的程序。Java 类都会包含一个静态方法 main()，它有一个 String 数组类型的参数 args[]。这个数组的内容就是我们输入的命令行参数，操作系统会将它传递给 java。Java和操作系统都默认参数为字符串。如果我们需要的某个参数是数字，我们会使用类似 Integer.parseInt() 的方法将其转换为适当的数据类型的值。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-fb46a261be3ffc84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.1.9.2 标准输出

![image.png](https://upload-images.jianshu.io/upload_images/4164292-fc2b4677710b858b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.3 格式化输出

![image.png](https://upload-images.jianshu.io/upload_images/4164292-7b2adf4b3e713aad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.1.9.4 标准输入

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f59945e64747f573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
public class Average
{
  public static void main(String[] args)
  {
    // 取StdIn中的所有数的平均数
    double sum = 0.0;
    int cnt = 0;
    while (!StdIn.isEmpty())
    {//读取一个数并计算累计之和
       sum += StdIn.readDouble();
       cnt++;
    }
    double avg = sum / cnt;
    StdOut.printf("Average is %.5f\n", avg);
  }
}
```

在终端输入：

```
% java Average 
1.23456
2.34567
3.45678
4.56789
//输出结果：
<ctrl-d>
Average is 2.90123
```

#### 1.1.9.5 重定向与管道

![命令行的重定向与管道.png](https://upload-images.jianshu.io/upload_images/4164292-1b99f348873f4666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.6 基于文件的输入输出

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8237edf50cdad2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.7 标准会图库（基本方法）

![标准绘图库的静态方法的API.png](https://upload-images.jianshu.io/upload_images/4164292-d98e5c7f45d35f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.7 标准绘图库（控制方法）

![image.png](https://upload-images.jianshu.io/upload_images/4164292-87ed187ed412ebfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

StdDraw 绘图举例：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8337e348b50cf0f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.10 二分查找

我们要学习的第一个 Java 程序的示例程序就是著名、高效且应用广泛的二分查找算法。具体 Java 代码实现如下：

```
import java.util.Arrays;//导入一个java库
//代码文件名必须是 BinarySearch.java
public class BinarySearch
{
  //静态方法
  public static int rank(int key, int[] a)
  {
    // 二分查找的数组必须是有序的
    int lo = 0;//初始化声明语句
    int hi = a.lenght - 1;
    while (lo <= hi)
    {//被查找的键要么不存在，要么必然存在于 a[lo..hi]之中
      int mid = lo + (hi - lo) / 2;
      if (key < a[mid]) hi = mid - 1;
      else if (key > a[mid]) lo = mid + 1;
      else return mid;
    }
    return -1;
  }
  
  public static void main(String[] args)
  {
    int[] whitelist = In.readInts(args[0]);
    Arrays.sort(whitelist);//调用Java库中的sort方法
    while (!StdIn.isEmpty())
    {
      //isEmpty方法和readInt方法：调用标准库中的方法
      // 读取键值，如果不存在于白名单中则将其打印
      int key = StdIn.readInt();
      if (rank(key, whitelist) == -1)
        StdOut.println(key);
    }
  }
}
```

```
% java BinarySearch tinyW.txt < tinyT.txt
50
99
13
```

这段程序接受了一个白名单文件（一列整数）作为参数，并会过滤掉标准输入中的所有存在于白名单中的条目，仅将不在白名单上的整数打印到标准输出中。它在rank()静态方法中实现了二分查找算法并高效地完成了这个任务。关于二分查找算法的完整讨论，包括它的正确性、性能分析及其应用，详见3.1节。

#### 1.1.10.1 二分查找原理

二分查找算法是由静态方法 rank() 实现的，它接受一个整数键和一个已经有序的int 数组作为参数。如果该键存在于数组中则返回它的索引，否则返回 -1。算法使用两个变量 lo 和 hi，并保证如果键在数组中则它一定在 a[lo..hi]中，然后方法进入一个循环，不断将数组中的中间键（索引为 mid）和被查找的键比较。如果被查找的键等于 a[mid]，则返回 mid；否则算法就将查找范围缩小一半，如果被查找的键小于 a[mid] 就继续在左半边查找，如果被查找的键大于 a[mid] 就继续在右半边查找。算法找到被查找的键或是查找范围为空时该过程结束。二分查找之所以快就是因为它只需检查很少几个条目（相对于数组的大小）就能够找到目标元素（或者确认目标元素不存在）。

#### 1.1.10.2 开发用例

在这个例子中，这个用例会从命令行指定的文件（tinyT.txt）中读取多个整数，并会打印出标准输入（tinyW.txt）中所有不存在于该文件中的整数。我们使用了图1.1.8所示的几个较小的测试文件来展示它的行为，这些文件也是图1.1.7中的跟踪和例子的基础。我们会使用较大的测试文件来模拟真实应用并测试算法的性能（详见1.1.10.3节）。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-dfeb3918bfe060f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.10.3 白名单过滤

如果可能，我们的测试用例都会通过模拟实际情况来展示当前算法的必要性。这里该过程被称为白名单过滤。具体来说，可以想象一家信用卡公司，它需要检查客户的交易账号是否有效。为此，它需要：

* 将客户的账号保存在一个文件中，我们称它为白名单；
* 从标准输入中得到每笔交易的账号；
* 使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易。

在一家有上百万客户的大公司中，需要处理数百万甚至更多的交易是很正常的。为了模拟这种情况，我们在本书网站上提供了文件 largeW.txt(100万个整数)和largeT.txt（1000万个整数），其基本情况如图1.1.9所示：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c0a1e3990c52af23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.10.4 性能

一个程序只是可用往往是不够的。例如，以下 rank() 的实现也可以很简单，它会检查数组的每个元素，甚至都不需要数组是有序的：

```
public static int rank(int key, int[] a) 
{
  for (int i = 0; i < a.lenght; i++)
    if (a[i] == key) return i;
   return -1;
}
```

有了这个简单易懂的解决方案，我们为什么还需要归并排序和二分查找呢？在练习1.1.38中可以看到计算机用 rank() 方法的暴力实现处理大量输入（比如含有100万个条目的白名单和1000万条交易）非常慢。如果不采用像二分查找或者归并排序这样的高效算法，是无法解决大规模的白名单问题的。良好的性能常常是极为重要的。因此我们会在1.4节中为性能研究做一些铺垫，并会分析我们学习的所有算法的性能特点（包括2.2节的归并排序和3.1节中的二分查找）。


## 1.2 数据抽象

数据抽象指的是一组值和一组对这些值的操作的集合。

Java编程的基础主要是使用 class 关键字构造被称为引用类型的数据类型。这种编程风格也称为面向对象编程。因为它的核心概念是对象，即保存了某个数据类型的值的实体。如果只有 Java 的原始数据类型，我们的程序会很大程度上被限制在算数计算上，但有了引用类型，我们就能编写操作字符串、图像、声音以及 Java 的标准库中或者本书的网站上的数百种抽象类型的程序。而且能够定义自己的数据类型来抽象任意对象。

抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型。

### 1.2.1 使用抽象数据类型

要使用一种数据类型并不一定非得知道它是如何实现的，所以我们首先来编写一个使用一种名为 Counter（计数器）的简单数据类型的程序。它的值是一个名称和一个非负整数，它的操作有创建对象并初始化为0，当前值加1和获取当前值。这个抽象对象在许多场景中都会用到。例如，这样一个数据类型可以用于电子机票软件，它能够保证投票者所能进行的唯一操作就是将他选择的候选人的计数器加1。我们也可以在分析算法性能时使用 Counter 来记录基本操作的调用次数。要使用 Counter 对象，首先需要了解应该如何定义数据类型的操作，以及在 Java 语言中应该如何创建和使用某个数据类型的对象。这些机制在现代编程中非常重要。

#### 1.2.1.1 抽象数据类型的 API

我们使用应用程序编程接口（API）来说明抽象数据类型的行为。它将列出所有构造函数和实例方法（即操作）并简要描述它们的功用。

抽象数据类型的定义和静态方法库之间有许多共同之处：

* 两者的实现均为 Java 类；
* 实例方法可能接受 0 个或者多个指定类型的参数，由括号表示并由逗号分隔；
* 它们可能会返回一个指定类型的值，也可能不会（用 void 表示）。

抽象数据类型的定义和静态方法库的三个不同：

* API中可能会出现若干个名称和类名相同且没有返回值的函数。这些特殊的函数被称为**构造函数**。在本例中， Counter 对象有一个接受一个 String 参数的构造函数。
* 实例方法不需要 static 关键字。它们不是静态方法，它们的目的就是操作该数据类型中的值。
* 某些实例方法的存在是为了尊重 Java 的习惯。我们将此类方法称为继承的方法并在 API 中将它们显示为灰色。

![计数器 Counter 的API.png](https://upload-images.jianshu.io/upload_images/4164292-896c292c5036dc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


这份 API 告诉我们可以通过构造函数 Counter()、实例方法 increment() 和 tally()，以及继承的 toString() 方法使用 Counter 类型的对象。

#### 1.2.1.2 继承的方法

根据 Java 的约定，任意数据类型都能通过在 API中包含特定的方法从 Java 的内在机制中获益。例如，Java中的所有数据类型都会继承 toString() 方法来返回用 String 表示的该类型的值。Java 会在用 + 运算符将任意数据类型的值和 String 值连接时调用该方法。该方法的默认实现并不实用（它会返回用字符串表示的该数据类型值的内存地址），因此我们常常会提供实现来重载默认实现，并在此时在 API 中加上 toString() 方法。此类方法的例子还包括 equals()、compareTo() 和hashCode()等。

#### 1.2.1.3 用例代码

#### 1.2.1.4 对象

一般来说，可以声明一个变量 heads 并将它通过以下代码和 Counter 类型的数据关联起来：

```
Counter heads;
```

对象是能够承载数据类型的值的实体。所有对象都有三大重要特性：状态、标识和行为。对象的状态即数据类型中的值。对象的标识能够将一个对象区别于另一个对象。可以认为对象的标识就是它在内存中的位置。对象的行为就是数据类型的操作。数据类型的实现的唯一职责就是维护一个对象的身份，这样用例代码在使用数据类型时只需遵守描述对象行为的API即可，而无需关注对象的表示方法。对象的状态可以为用例代码提供信息，或是产生某种副作用，或是被数据类型的操作所改变。但数据类型的值的表示细节和用例代码是无关的。

引用是访问对象的一种方式。 Java 使用术语**引用类型**以示和原始数据类型（变量和值相关联）的区别。

#### 1.2.1.5 创建对象

每种数据类型的值都存储于一个对象中。要创建（或实例化）一个对象，我们用关键字 new 并紧跟类名以及()（或在括号中指定一系列的参数，如果构造函数需要的话）来触发它的构造函数。构造函数没有返回值，因为它总是返回它的数据类型的对象的引用。每当用例调用了 new()，系统都会：

* 为新的对象分配内存空间；
* 调用构造函数初始化对象中的值；
* 返回该对象的一个引用。

在用例代码中，我们一般都会在一条声明语句中创建一个对象并通过将它和一个变量关联来初始化该变量，和使用原始数据类型时一样。和原始数据类型不同的是，变量关联的是指向对象的引用而非数据类型的值本身。我们可以用同一个类创建无数对象，每个对象都有自己的标识，且所存储的值和另一个相同类型的对象可以相同也可以不同。例如，以下代码中创建了两个不同的 Counter 对象：

```
Counter heads = new Counter("heads");
Counter tails = new Counter("tails");
```

抽象数据类型向用例隐藏了值的表示细节。可以假设每个 Counter 对象中的值是一个 String 类型的名称和一个 int 计数器，但不能编写依赖于任何特定表示方法的代码（即使知道假设是否正确，也许计数器是一个long值）对象的创建过程如图1.2.2所示。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-1697b9c5a4f29eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1。2.1.6 调用实例方法

实例方法的意义在于操作数据类型中的值，因此 Java 语言提供了一种特别的机制来触发实例方法，它突出了实例方法和对象之间的联系。具体来说，我们调用一个实例方法的方式是先写出对象的变量名，紧接着是一个句点，然后是实例方法的名称。实例方法可能会改变数据类型中的值，也可能只是访问数据类型中的值。实例方法拥有我们在1.1.6.3节讨论过的静态方法的所有性质：参数按值传递，方法名可以被重载，方法可以有返回值，它们也许还会产生一些副作用。但它们还有一个特别的性质：方法的每次触发都是和一个对象相关的。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c578001b282d919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

静态方法的主要作用是实现函数；非静态（实例）方法的主要作用是实现数据类型的操作。此外静态方法调用的开头是类名（按习惯为大写），而非静态方法调用的开头总是对象名（按习惯为小写）。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f2319cb2c2a34ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.1.7 使用对象

通过声明语句可以将变量名赋给对象，在代码中，我们不仅可以用该变量创建对象和调用实例方法，也可以像使用整数、浮点数和其他原始数据类型的变量一样使用它。要开发某种给定数据类型的用例，我们需要：

* 声明该类型的变量，以用来引用对象；
* 使用关键字 new 触发能够创建该类型的对象的一个构造函数；
* 使用变量名在语句或表达式中调用实例方法。

#### 1.2.1.8 赋值语句

使用引用类型的赋值语句将会创建该引用的一个副本。赋值语句不会创建新的对象，而只是创建另一个指向某个已经存在的对象而已。这种情况被称为别名：两个变量同时指向同一个对象。别名的效果可能会导致一些莫名奇妙的问题。如果 x 和 y 是原始数据类型的变量，那么赋值语句 x=y 会将y的值复制到x中。对于引用类型，复制的是引用（而非实际的值）。在 Java 中，别名是导致bug的常见原因。

```
Counter c1 = new Counter("ones");
c1.increment();
Counter c2 = c1;
c2.increment();
StdOut.println(c1);
```
打印结果是“2 ones”，这种bug就是因为别名引起的。也就是说改变一个对象的状态将会影响到所有和该对象的别名有关的代码。

#### 1.2.1.9 将对象作为参数

**形参**：方法被调用时需要传递进来的参数。如func(int a)中的a，它只有在func方法被调用时a才有意义，也就是会被分配内存空间，在方法func执行完成后，a的内存空间就会被释放掉，a对象也就被销毁了。

**实参**：方法被调用时传入的实际值。它在方法被调用前就已经被初始化并且在方法被调用时传入。

```
Person per = new Person();
```

实际上，它也是有两个过程：

```
Person per;//定义变量
per = new Person();//赋值
```

在执行 Person per 时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person() 时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。由此可见：对于引用数据类型的对象、数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。

**值传递**：在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内部对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值。

**引用传递**：指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参。在方法体内，形参和实参指向同一块内存地址，因此对形参的操作会影响实参值。

```
// Person 类
public class Person {
  private String name;
  private int age;
  
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public int getAge() {
    return age;
  }
  public void setAge(int age) {
    this.age = age;
  }
 }
 
public static void PersonCrossTest(Person person){
  System.out.println("传入的person的name："+person.getName());
  person.setName("我是bhl");
  System.out.println("方法内重新赋值后的name："+person.getName());
}
//测试
public static void main(String[] args) {
  Person p=new Person();
  p.setName("我是fqy");
  p.setAge(45);
  PersonCrossTest(p);
  System.out.println("方法执行后的name："+p.getName());
}
输出结果：
传入的person的name：我是fqy
方法内重新赋值后的name：我是bhl
方法执行后的name：我是bhl
```

[Java中的值传递和地址传递详解](https://blog.csdn.net/bntx2jsqfehy7/article/details/83508006)

#### 1.2.1.10 将对象作为返回值

也可以将对象作为方法的返回值。方法可以将它的参数对象返回，也可以创建一个对象并返回它的引用。这种能力非常重要，因为 Java 中的方法只能有一个返回值，但是有了对象我们的代码实际上就能返回多个值。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f75ca45c995836b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.1.11 数组也是对象

在 Java中，所有非原始数据类型的值都是对象。也就是说，数组也是对象。和字符串一样， Java 语言对于数组的某些操作有特殊的支持：声明、初始化和索引。和其他对象一样，当我们将数组传递给一个方法或是将一个数组变量放在赋值语句的右侧时，我们都是在创建该数组引用的一个副本，而非数组的副本。对于一般情况，这种效果正是我们所期望的，因为我们期望方法能够重新安排数组的条目并修改数组的内容，如 java.utils.Array.sort() 或表 1.1.10讨论的 shuffle() 方法。

#### 1.2.1.12 对象的数组

数组元素可以是任意类型的数据。我们实现的 main() 方法的 args[] 参数就是一个 String 对象的数组。创建一个对象数组需要以下两个步骤：

* 使用方括号语法调用数组的构造函数创建数组；
* 对于每个数组元素调用它的构造函数创建相应的对象。

在Java中，对象数组就是一个由对象的引用而组成的数组，而非所有对象本身组成的数组。如果对象非常大，那么在移动它们时由于只需要操作引用而非对象本身，这就会大大提高效率；如果对象很小，每次获取信息时都需要通过引用反而会降低效率。

下面这段代码模拟的是掷骰子。它使用了一个 Counter 对象的数组来记录每种可能的值的出现次数。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-257c27bc059073e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

运用**数据抽象的思想**编写代码（定义和使用数据类型，将数据类型的值封装在对象中）的方式成为**面向对象编程**。**数据类型**指的是一组值和一组对值的操作的集合。我们会将数据类型实现在独立的 Java 类模块中并编写它们的用例。对象是能够存储任意该数据类型的值的实体，或数据类型的实例。对象有三大关键性质：状态、标识和行为。

一个数据类型的实现所支持的操作如下：

* **创建对象**（创造它的标识）：使用 new 关键字触发构造函数并创建对象，初始化对象中的值并返回对它的引用。
* **操作对象中的值**（控制对象的行为，可能会改变对象的状态）：使用和对象关联的变量调用实例方法来对对象中的值进行操作
* **操作多个对象**：创建对象的数组，像原始数据类型的值一样将它们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身。

这些能力是这种灵活且应用广泛的现代编程方式的基础，也是我们在本书中对算法研究的基础。


### 1.2.2 抽象数据类型举例

本书中将会用到或开发的所有数据类型可以被分为以下几类：

* java.lang.* 中的标准系统抽象数据类型，可以被任意 Java 程序调用。
* Java标准库中的抽象数据类型，如 java.swt、java.net 和 java.io，它们也可以被任意 Java 程序调用，但需要 import 语句。
* I/O 处理类抽象数据类型，和 StdIn 和 StdOut 类似，允许我们处理多个输入输出流。
* 面向数据类抽象数据类型，它们的主要作用是通过封装数据的表示简化数据的组织和处理。
* 集合类抽象数据类型，它们的主要用途是简化对同一类型的一组数据的操作。
* 面向操作的抽象数据类型。
* 图算法相关的抽象数据类型。

#### 1.2.2.1 几何对象

处理几何对象的程序在自然世界模型、科学计算、电子游戏、电影等许多应用的计算中有着广泛的应用。此类程序的研发已经发展成了**计算机几何学**这门影响深远的研究学科。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8f0400f029bcf666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-3900c4199f17be3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-10bcb9d3250e2799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Interval2D的测试用例：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-52e747a2c118111f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.2.2 信息处理

无数应用的核心都是组织和处理信息。抽象数据类型是组织信息的一种自然方式。表1。2.6中的两份API也展示了商业应用程序中的一种典型做法。这里的主要思想是定义和真实世界中的物体相对应的对象。一个日期就是一个日、月和年的集合，一笔交易就是一个客户、日期和金额的集合。

**每种数据类型都包含能够创建对象的构造函数和用于访问其中数据的方法**。为了简化用例的代码，我们为每个类型都提供了两个构造函数，一个接受适当类型的数据，另一个则能够解析字符串中的数据。

#### 1.2.2.3 字符串

一个 String 值是一串可以由索引访问的 char 值。String对象拥有很多实例方法。Java 的字符串部分API如下：

```
Public class String
       String() //创建一个空字符串
  int  length() //字符串长度
  int  charAt(int i) // 第i个字符
  int  indexOf(String p) //p第一次出现的位置（如果没有则返回 -1）
  int  indexOf(String p, int i) //p在i个字符后第一次出现的位置（如果没有则返回 -1）
  String concat(String t) // 将t附在该字符串末尾
  String substring(int i, int j) //该字符串的子字符串（第i个字符到第j-1个字符）
  String[] split(String delim) //使用delim分割符切分字符串
  int  compareTo(String t)  // 比较字符串
  boolean  equals(String t) //该字符串的值和t的值是否相同
  int hashCode() //散列值
```

![image.png](https://upload-images.jianshu.io/upload_images/4164292-9884c8f87e0bebc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

split()方法的参数可以是正则表达式。典型的字符串处理代码中split()的参数是“\\s+”，它表示“一个或多个制表符、空格、换行符或回车”。

#### 典型的字符串处理代码：

**1、判断字符串是否是一条回文：**

```
public static boolean isPalindrome(String s) {
  int N = s.length();
  for (int i = 0; i < N/2; i++)
    if (s.charAt(i) != s.charAt(N-1-i))
      return false;
    return true;  
}
```

**2、从一个命令行参数中提取文件名和扩展名：**

```
String s = args[0];
int dot = s.indexOF(".");
String base = s.substring(0, dot);
String extension = s.substring(dot + 1, s.length());
```

**3、打印出标准输入中所有含有通过命令行指定的字符串的行：**

```
String query = args[0];
while (!StdIn.isEmpty())
{
  String s = StdIn.readLine();
  if (s.contains(query))  StdOut.println(s);
}
```

**4、以空白字符为分隔符从StdIn中创建一个字符串数组：**

```
String input = StdIn.readAll();
String[] words = input.split("\\s+");
```

**5、检查一个字符串数组中的元素是否已按照字母表顺序排列：**

```
public boolean isSorted(String[] a)
{
  for (int i = 1; i < a.length; i++)
  {
    if (a[i-1].compareTo(a[i]) > 0)
      return false;
  }
  return true;
}
```

![image.png](https://upload-images.jianshu.io/upload_images/4164292-077486dec9b0b01e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-7431e81cc3e366ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.3 抽象数据类型的实现

![image.png](https://upload-images.jianshu.io/upload_images/4164292-52fb952eda3ded01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在抽象数据类型的实现中，我们会使用 private，也就是使用 Java 语言的机制来保证向使用者隐藏抽象数据类型中的数据表示。**如果某值在初始化之后不应该再被改变，那么需要使用 final关键字修饰**。

#### 1.2.3.2 构造函数

每个 Java 类都至少含有一个构造函数以创建一个对象的标识。构造函数类似于一个静态方法，但它能够直接访问实例变量且没有返回值。一般来说，构造函数的作用是初始化实例变量。每个构造函数都将创建一个对象并向调用者返回一个该对象的引用。构造函数的名称总是和类名相同。我们可以和重载方法一样重载这个名称并定义签名不同的多个构造函数。

如果没有定义构造函数，类将会隐式定义一个默认情况下不接受任何参数的构造函数并将所有实例变量初始化为默认值。原始数字类型的实例变量默认值为0，布尔类型变量为false，引用类型变量默认为null。我们可以在声明语句中初始化这些实例变量并改变这些默认值。

当用例使用关键字 new 时，Java 会自动触发一个构造函数。重载构造函数一般用于将实例变量由默认值初始化为用例提供的值。例如，Counter类型有个接受一个参数的构造函数，它将实例变量 name 初始化为由参数给定的值（实例变量count仍将被初始化为默认值0）

详解构造函数：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-71a25d2188d52987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.3.3 实例方法

实现数据类型的实例方法（即每个对象的行为）的代码和1.1节中实现静态方法（函数）的代码基本相同。实例方法和静态方法只有一点关键的不同：实例方法可以访问并操作实例变量。

每个实例方法都有一个返回值类型、一个签名（它指定了方法名、返回值类型和所有参数变量的名称）和一个主体（它由一系列语句组成，包括一个返回语句来将一个返回类型的值传递给调用者。）

当调用者触发了一个方法时，方法的参数（如果有）均会被初始化为调用者所提供的值，方法的语句被执行，直到得到一个返回值并且将该值返回给调用者。

详解实例方法：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-3e8f902e78fc700b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.3.4 作用域

在实现实例方法的 Java代码中使用了三种变量：参数变量、局部变量、实例变量。

参数变量的作用域是整个方法；局部变量的作用域是当前代码段中它的定义之后的所有语句；实例变量的作用域是整个类。需要注意的是，如果出现二义性，可以使用this.实例变量名来加以区别。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-d32005795152b4f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.3.5 API、用例与实现

我们会按照三步走的方式用抽象数据类型满足用例的需求：

* 定义一份 API：API的作用是将使用和实现分离，以实现模块化编程。
* 用一个 Java 类实现 API 的定义：首先我们选择适当的实例变量，然后再编写构造函数和实例方法。
* 实现多个测试用例来验证前两步做出的设计决定。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c76940374c5d1268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-74179296724f8b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.4.3 累加器

![image.png](https://upload-images.jianshu.io/upload_images/4164292-41f898471858d784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-89666e3d3a89b5b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.5 数据类型的设计

抽象数据类型是一种向用例隐藏内部表示的数据类型。这种思想强有力地影响了现代编程。

#### 1.2.5.1 封装

面向对象编程的特征之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发。封装实现了模块化编程。封装同时也隔离了数据类型的操作。

一个封装的数据类型可以被任意用例使用，因此它扩展了Java 语言。我们所提倡的编程风格是**将大型程序分解为能够独立开发和调试的小型模块。这种方式将修改代码的影响限制在局部区域，改进了我们的软件质量。它也促进了代码的复用，因为我们可以用某种数据类型的新实现代替老的实现来改进它的性能、准确度或是内存消耗**。

在算法和数据结构的学习中，我们总是希望开发出更好的算法，因为只需用抽象数据类型的改进实现替换老的实现即可在不改变任何用例代码的情况下改进所有用例的性能。模块化编程成功的关键在于保持模块之间的独立性。我们坚持将 API 作为用例和实现之间唯一的依赖点来做到这一点。并不需要知道一个数据类型是如何实现的才能使用它，实现数据类型也应该假设使用者除了API之外什么也不知道。封装是获得所有这些优势的关键。

#### 1.2.5.2 设计 API

构建现代软件最重要也最有挑战的一项任务就是设计 API。它需要经验、思考和反复的修改，但设计一份优秀的API所付出的所有时间都能从调试和代码复用所节省的时间中获得回报。

设计API时可以参照“只为用例提供它们所需要的，仅此而已。”这句话。

#### 二分查找 & 面向对象

将二分查找重写为一段面向对象的程序，用于在整数集合中进行查找的一种抽象数据类型。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-e8840e68be2ab5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-0a40f0c96f74a8d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.5.4 接口继承

Java语言为定义对象之间的关系提供了支持，称为接口。

#### 1.2.5.5 实现继承

Java 还支持另一种继承机制，被称为子类。这种非常强大的技术使程序员不需要重写整个类就能改变它的行为或者为它添加新的功能。它的主要思想是定义一个新类（子类或称为派生类）来继承另一个类（父类或称为基类）的所有实例方法和实例变量。子类包含的方法比父类更多。另外，子类可以重新定义或重写父类的方法。

每个类都是 Java的Object类的子类。这种结构意味着每个类都含有 getClass()、toString()、equals()、hashCode()和另外几个我们不会在本书中用到的方法的实现。实际上，每个类都通过子类继承从Object类中继承了这些方法，因此任何用例都可以在任意对象中调用这些方法。我们通常会重载新类的 toString()、equals()和hashCode()方法。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-91e6f36d807ca661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.5.7 封装类型

Java提供了一些内置的引用类型，称为封装类型。每种原始数据类型都有一个对应的封装类型：Boolean、Byte、Character、Double、Float、Integer、Long和Short分别对应着 boolean、byte、char、double、float、int、long和short。这些类主要由类似于parseInt()这样的静态方法组成。但它们也含有继承得到的实例方法 toString()、compareTo()、equals()和hashCode()。在需要的时候Java会自动将原始数据类型转换为封装类型。例如，当一个int值需要和一个String连接时，它的类型会被转换为Integer并触发 toString()方法。

#### 1.2.5.8 等价性

![image.png](https://upload-images.jianshu.io/upload_images/4164292-cab0ce0fde145e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.2.5.9 内存管理

Java最重要的一个特性就是自动内存管理。它通过记录孤儿对象并将它们的内存释放到内存池中将程序员从管理内存的责任中解放出来。这种回收内存的方式叫做垃圾回收。

#### 1.2。5.10 不可变性

Java语言通过 final 修饰符来强制保证不可变性。当你将一个变量声明为 final 时，也就保证了只会对它赋值一次，可以用赋值语句，也可以用构造函数。试图改变final 变量的值的代码将会产生一个编译时错误。需要注意的是，final只能用来保证原始数据类型的实例变量的不可变性，而无法用于引用类型的变量。

String对象是不可变的，而Java数组是可变的。当我们希望使用可变字符串时可以使用 StringBuilder类，当希望使用不可变数组时可以使用 Vector 类。

##### 1.2.5.11 契约式设计

* 异常（Exception），一般用于处理不受我们控制的不可预见的错误。
* 断言（Assertion），验证我们在代码中做出的一些假设。断言的作用是调试，程序在正常操作中不应该依赖断言。

## 1.3 背包、队列和栈

数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。本节学习三种这样的数据类型，分别是背包（Bag）、队列（Queue）和栈（Stack）。它们的不同之处在于删除或访问对象的顺序不同。本节中的实现和用例代码也展示了我们开发数据结构和算法的一般方式。

本节的第一个目标是说明我们对集合中的对象的表示方式将直接影响各种操作的效率。对于集合来说，我们将会设计适于表示一组对象的数据结构并高效地实现所需的方法。

本节的第二个目标是介绍泛型和迭代。它们都是简单的 Java 概念，但能极大地简化用例代码。它们是高级的编程语言机制，虽然对于算法的理解并不是必需的，但是有了它们我们能够写出更加清晰、简洁和优美的用例（以及算法的实现）代码。

本节的第三个目标是介绍并说明链式数据结构的重要性，特别是经典数据结构链表，有了它我们才能高效地实现背包、队列和栈。**理解链表是学习各种算法和数据结构中最关键的第一步**。

### 1.3.1 API

![image.png](https://upload-images.jianshu.io/upload_images/4164292-24d7f637d23624b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-a53876112803f9d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如表1.3.1所示，每份API都含有一个无惨的构造函数、一个向集合中添加单个元素的方法、一个测试集合是否为空的方法和一个返回集合大小的方法。Stack和Queue都含有一个能够删除集合中的特定元素的方法。除了这些基本内容之外，我们将在以下几节中解释这几份API反映出的两种Java特性：泛型与迭代。

#### 1.3.1.1 泛型

集合类的抽象数据类型的一个关键特性是我们应该可以用它们存储任意类型的数据。一种特别的Java机制能够做到这一点，它被称为**泛型**，也叫做**参数化类型**。泛型对编程语言的影响非常深刻，许多语言并没有这种机制。

在每份 API 中，类名后的<Item>记号将 Item 定义为一个类型参数，它一个象征性的占位符，表示的是用例将会使用的某种具体数据类型。可以将 Stack<Item>理解为某种元素的栈。在实现 Stack 时，我们并不知道 Item的具体类型，但用例可以用我们的栈处理任意类型的数据，甚至是在我们实现之后才出现的数据类型。在创建栈时，用例会提供一种具体的数据类型：我们可以将Item替换为任意引用数据类型（Item出现的每个地方都是如此）。这种能力正是我们所需要的。例如，可以编写如下代码来用栈处理String 对象：
  
```
Stack<String> stack = new Stack<String>();
stack.push("Test");
...
String next = stack.pop();
```

并在以下代码中使用队列处理 Date 对象：

```
Queue<Date> queue = new Queue<Date>();
queue.enqueue(new Date(12, 31, 1999));
...
Date next = queue.dequeue();
```

如果你尝试向 stack 变量中添加一个 Date 对象（或是任何其他非 String 类型的数据）或是向queue变量中添加一个String对象（或是任何其他非 Date类型的数据），都会得到一个编译时错误。如果没有泛型，我们必须为需要收集的每种数据类型定义（并实现）不同的API。有了泛型，我们只需要一份 API（和实现一次）就能够处理所有类型的数据，甚至是在未来定义的数据类型。

#### 1.3.1.2 自动装箱

类型参数必须被实例化为引用类型，因此Java有一种特殊机制来使泛型代码能够处理原始数据类型。我们还记得 Java 的封装类型都是原始数据类型所对应的引用类型：Boolean、Byte、Character、Double、Float、Integer、Long和 Short 分别对应着 boolean、byte、char、double、float、int、long 和 short。在处理赋值语句、方法的参数和算术或逻辑表达式时， Java 会自动在引用类型和对应的原始数据类型质检进行转换。这种转换有助于我们同时使用泛型和原始数据类型。

例如：

```
Stack<Integer> stack = new Stack<Integer>();
stack.push(17);//自动装箱（int -> Integer）
int i = stack.pop();//自动拆箱（Integer -> int）
```

自动将一个原始数据类型转换为一个封装类型被称为**自动装箱**，自动将一个封装类型转换为一个原始数据类型被称为**自动拆箱**。在这个例子中，当我们将一个原始类型的值 17 传递给 push() 方法时， Java将它的类型自动转换（自动装箱）为Integer。pop()方法返回了一个 Integer 类型类型的值，Java在将它赋予变量 i 之前将它的类型自动转换（自动拆箱）为了 int。

#### 1.3.1.3 可迭代的集合类型

对于许多应用场景，用例的要求只是用某种方式处理集合中的每个元素，或者叫做迭代访问集合中的所有元素。这种模式非常重要，在 Java 和其他许多语言中它都是一级语言特性（不只是库，编程语言本身就含有特殊的机制来支持它）。有了它，我们能够写出清晰简洁的代码且不依赖于集合类型的具体实现。

例如，假设用例在 Queue 中维护一个交易集合，如下：

```
Queue<Transaction> collection = new Queue<Transaction>();
```

如果集合是可迭代的，用例用一行语句即可打印出交易的列表：

```
for (Transaction t : collection)
{ StdOut.println(t); }
```

这种语法叫做 foreach 语句：可以将 for 语句看做对于集合中的每个交易 t（foreach），执行以下代码段。这段用例代码不需要知道集合的表示或实现的任何细节，它只想逐个处理集合中的元素。相同的 for 语句也可以处理交易的 Bag 对象或是任何可迭代的集合。


#### 1.3.1.4 背包

背包是一种不支持从中删除元素的集合数据类型。它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例也可以检查背包是否为空或者获取背包中元素的数量）。迭代的顺序不确定且与用例无关。要理解背包的概念，可以想象一个非常喜欢收集玻璃球的人。他将所有的玻璃球都放在一个背包里，一次一个，并且会不时在所有的玻璃球中寻找某一颗拥有某种特点的玻璃球。使用 Bag 的 API，用例可以将元素添加进背包并根据需要随时使用 foreach 语句访问所有的元素。用例也可以使用栈或是队列，但使用 Bag 可以说明元素的处理顺序不重要。

它的任务是简单地计算标准输入中的所有 double 值的**平均值和样本标准差**。如果标准输入中有 N 个数字，那么平均值为它们的和除以 N，样本标准差为每个值和平均值之差的平方之和除以 N-1 之后的平方根。在这些计算中，数的计算顺序和结果无关，因此我们将它们保存在一个 Bag 对象中并使用 foreach 语法来计算每个和。

背包的典型用例：

```
public class Stats
{
  public static void main(String[] args)
  {
    Bag<Double> numbers = new Bag<Double>();
    while (!StdIn.isEmpty())
      numbers.add(StdIn.readDouble());
      
    int N = numbers.size();
    
    double sum = 0.0;
    for (double x : numbers)
      sum += x;
    double mean = sum/N;
    
    sum = 0.0;
    for (double x : numbers)
      sum += (x - mean) * (x - mean);
    double std = Math.sqrt(sum/(N-1));
    
    StdOut.printf("Mean:%.2f\n",mean);
    StdOut.printf("Std dev: %.2f\n", std);
  }
}
```
#### 1.3.1.5 先进先出队列

先进先出队列（或简称队列）是一种基于先进先出（FIFO）策略的集合类型，如图1.3.2所示。按照任务产生的顺序完成它们的策略我们每天都会遇到：在剧院门前排队的人们、在收费站前排队的汽车或是计算机上某种软件中等待处理的任务。任何服务性策略的基本原则都是公平。在提到公平时大多数人的第一个想法就是应该优先服务等待最久的人，这正是先进先出策略的准则。队列是许多日常现象的自然模型，它也是无数应用程序的核心。当用例使用foreach语句迭代访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。在应用程序中使用队列的主要原因是在用集合保存元素的同时保存它们的相对顺序：使它们入列顺序和出列顺序相同。

例如，下面用例是我们的 In 类的静态方法 readInts()的一种实现。这个方法为用例解决的问题是用例无需预先知道文件的大小即可将文件中的所有整数读入一个数组中。我们首先将所有的整数读入队列中，然后使用 Queue 的size()方法得到所需数组的大小，创建数组并将队列中的所有整数移动到数组中。队列之所以合适是因为它能够将整数按照文件中的顺序放入数组中（如果该顺序并不重要，也可以使用 Bag 对象）。这段代码使用了自动装箱和拆箱来转换用例中的 int 原始数据类型和队列的 Integer 封装类型。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-bdb5070dc9b21348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**Queue的用例**：

```
public static int[] readInts(String name)
{
  In in = new In(name);
  Queue<Integer> q = new Queue<Integer>();
  while (!in.isEmpty())
    q.enqueue(in.readInt());
    
  int N = q.size();
  int[] a = new int[N];
  for (int i = 0; i < N; i++)
    a[i] = q.dequeue();
  return a;
}
```

#### 1.3.1.6 下压栈（Stack）

下压栈（或简称栈）是一种基于后进先出（LIFO）策略的集合类型，如图1.3.3所示。当你的邮件在桌上放成一叠时，使用的就是栈。新邮件来到时你将它们放在最上面，当你有空时你会一封一封地从上到下阅读它们。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-b93e047b363c406f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

计算机上的许多常用程序遵循相同的组织原则。例如，许多人仍然用栈的方式存放电子邮件：在收信时将邮件压入（push）最顶端，在取信时从最顶端将它们弹出（pop），且第一封一定是最新的邮件（后进，先出）。这种策略的好处是我们能够及时看到感兴趣的邮件，坏处是如果你不把栈清空，某些较早的邮件可能永远也不会被阅读。


当用例使用 foreach 语句迭代遍历栈中的元素时，元素的处理顺序和它们被压入的顺序正好相反。在应用程序中使用栈迭代器的一个典型原因是在用集合保存元素的同时颠倒它们的相对顺序。

例如 Reverse 用例将会把标准输入中的所有整数逆序排列，同样它也无需预先知道整数的多少。在计算机领域，栈具有基础而深远的影响。

**栈的用例**：

```
public class Reverse
{
  public static void main(String[] args)
  {
    Stack<Integer> stack;
    stack = new Stack<Integer>();
    while (!StdIn.isEmpty()) 
      stack.push(StdIn.readInt());
      
    for (int i : stack)
      StdOut.println(i);
  }
}
```

#### 1.3.1.7 算术表达式求值

```
( 1 + ((2 + 3) * (4 * 5))))
```

如何解析由括号、运算符和数字组成的字符串，并按照正确的顺序完成各种初级算术运算操作呢？E.W.Dijkstra 在20世纪60年代发明了一个非常简单的算法，用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务。

表达式由括号、运算符和操作数（数字）组成。我们根据以下4种情况从左到右逐个将这些实体送入栈处理：

* 将操作数压入操作数栈；
* 将运算符压入运算符栈；
* 忽略左括号；
* 在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。

在处理完最后一个右括号之后，操作数栈上只会有一个值，它就是表达式的值。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-89e6f112d752dc2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这段 Stack 的用例使用了两个栈来计算表达式的值。它展示了一种重要的计算模型：将一个字符串解释为一段程序并执行该程序得到结果。有了泛型，我们只需实现 Stack 一次即可使用 String 值的栈和 Double 值的栈。

**DiJkstra的双栈算术表达式求值算法的轨迹**：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-941f6c16b9a6f1e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.3.2 集合数据类型的实现

在讨论 Bag、Stack 和 Queue 的实现之前，我们会先给出一个简单而经典的实现，然后讨论它的改进并得到表 1.3.1中的 API 的所有实现。

#### 1.3.2.1 定容栈

![image.png](https://upload-images.jianshu.io/upload_images/4164292-5e519186e6df9113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**数据类型的实现**：

```
public class FixedCapacityStackOfStrings
{
  private String[] a;//用于保存栈中的元素的数组a[]
  private int N;//用于保存栈中的元素数量的整数N。
  public FixedCapacityStackOfStrings(int cap)
  { a = new String[cap]; }
  public boolean isEmpty() { return N ==0; }
  public int size() { return N; }
  public void push(String item)
  { a[N++] = item; }//要添加一个元素，将a[N]设为新元素并将N加1
  public String pop()
  { return a[--N]; }//要删除一个元素，将N减1并返回a[N]
}
```

![image.png](https://upload-images.jianshu.io/upload_images/4164292-152a365e37d69688.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.3.2.2 泛型

FixedCapacityStackOfString 的第一个缺点是它只能处理 String 对象。如果需要一个 double值的栈，就需要用类似的代码实现另一个类，也就是把所有的String 都替换为 double。此外，我们还可能需要 Transaction 类型的栈或者 Date 类型的队列等。Java的参数类型（泛型）就是专门用来解决这个问题的。那么如何才能实现一个泛型的栈呢？表1.3.4中的代码展示了实现的细节。它实现了一个 FixedCapacityStack 类，该类和 FixedCapacityStackOfString 类的区别在于加粗部分的代码。即：我们把所有的 String 都替换为 Item（一个地方除外，会在稍后讨论）并用下面这行代码声明该类：

```
public class FixedCapacityStack<Item>
```

Item是一个类型参数，用于表示用例将会使用的某种具体类型的象征性的占位符。可以将 FixedCapacityStack<Item>理解为某种元素的栈，这正是我们想要的。在实现 FixedCapacityStack 时，我们并不知道 Item 的实际类型，但用例只要能在创建栈时提供具体的数据类型，它就能用栈处理任意数据类型。Java会使用类型参数 Item来检查类型不匹配的错误。尽管具体的数据类型还不知道，赋予 Item 类型变量的值也必须是 Item 类型的。
  
在这里有一个细节非常重要：我们希望用以下代码在 FixedCapacityStack 的构造函数的实现中创建一个泛型的数组：

```
a = new Item[cap];
```

由于某些历史和技术原因，创建泛型数组在Java中是不允许的。我们需要使用类型转换：

```
a = (Item[]) new Object[cap];
```

这段代码才能够达到我们所期望的效果（但 Java 编译器会给出一条警告，不过可以忽略它）。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-559a1442dcfffe19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8dbdd0b2bb7392b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.3.2.3 调整数组大小

选择用数组表示栈内容意味着用例必须预先估计栈的最大容量。在 Java 中，数组一旦创建，其大小是无法改变的，因此栈使用的空间只能是这个最大容量的一部分。选择大容量的用例在栈为空或几乎为空时会浪费大量的内存。例如，一个交易系统可能会涉及数十亿笔交易和数千个交易的集合。即使这种系统一般都会限制每笔交易只能出现在一个集合中，但用例必须保证所有集合都有能力保存所有的交易。另一方面，如果集合变得比数组更大那么用例有可能溢出。为此，push()方法需要在代码中检测栈是否已满，我们的 API 中也应该含有一个 isFull() 方法来允许用例检测是否已满。

为此，我们修改了数组的实现，动态调整数组 a[] 的大小，使得它既足以保存所有元素，又不至于浪费过多的空间。实现方法是将栈移动到另一个大小不同的数组中：

```
private void resize(int max)
{
  //将大小为N <= max 的栈移动到一个新的大小为 max 的数组中
  Item[] temp = (Item[]) new Object[max];
  for (int i = 0; i < N; i++)
    temp[i] = a[i];
  a = temp;
}
```

在 push() 方法中，检查数组是否太小。具体来说，我们会通过检查栈大小N和数组大小 a.length 是否相等来检查数组是否能够容纳新的元素。如果没有多余的空间，我们会将数组的长度加倍。然后就可以和从前一样用 a[N++] = item 插入新元素了：

```
public void push(String item)
{
  // 将元素压入栈顶
  if (N == a.length) resize(2*a.length);
  a[N++] = item;
}
```

类似，在 pop() 中，首先删除栈顶的元素，然后如果数组太大我们就将它的长度减半。正确的检测条件是**栈大小是否小于数组的四分之一**。在数组长度被减半之后，它的状态约为半满，在下次需要改变数组大小之前仍然能够进行多次push()和pop()操作。

```
public String pop()
{
  //从栈顶删除元素
  String item = a[--N];
  a[N] = null;//避免对象游离
  if (N > 0 && N == a.length/4) resize(a.length/2);
    return item;
}
```

在这个实现中，栈永远不会溢出，使用率也永远不会低于四分之一（除非栈为空，那种情况下数组的大小为1）。

push() 和 pop() 操作中数组大小调整的轨迹见表1.3.5：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-529608356ae8afb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.3.2.4 对象游离

Java的垃圾收集策略是回收所有无法被访问的对象的内存。在我们对 pop() 的实现中，被弹出的元素的引用仍然存在于数组中。这个元素实际上已经是一个孤儿了。它永远也不会再被访问了，但Java的垃圾收集器没法知道这一点，除非该引用被覆盖。即使用例已经不再需要这个元素了，数组中的引用仍然可以让它继续存在。这种情况（保存一个不需要的对象的引用）称为**游离**。为了避免游离，**只需将被弹出的数组元素的值设为 null 即可。这将覆盖无用的引用并使系统可以在用例使用完被弹出的元素后回收它的内存**。

#### 1.3.2.5 迭代

集合类数据类型的基本操作之一就是，能够使用 Java 的 foreach 语句通过迭代遍历并处理集合中的每个元素。这种方式的代码既清晰又简洁，且不依赖于集合数据类型的具体实现。

在讨论迭代的实现之前，我们先看一段能够打印出一个字符串集合中的所有元素的用例代码：

```
Stack<String> collection = new Stack<String>();
...
for (String s : collection)
  StdOut.println(s);
...
```

这里，foreach 语句只是 while 语句的一种简写方式（就好像 for 语句一样）。它本质上和以下 while 语句是等价的：

```
Iterator<String> i = collection.iterator();
while (i.hasNext())
{
  String s = i.next();
  StdOut.println(s);
}
```

这段代码展示了一些在任意可迭代的集合数据类型中我们都需要实现的东西：

* 集合数据类型必须实现一个 iterator() 方法并返回一个 Iterator 对象；
* Iterator 类必须包含两个方法：hasNext()(返回一个布尔值)和 next()（返回集合中的一个泛型元素）。

在 Java 中，我们使用接口机制来指定一个类所必须实现的方法（详见1.2.5.4节）。对于可迭代的集合数据类型，Java已经为我们定义了所需的接口。要使一个类可迭代，第一步就是在它的声明中加入 implements Iterable<Item>，对应的接口（即 java.lang.Iterable）为：
  
```
public interface Iterable<Item>
{
  Iterator<Item> iterator();
}
```

然后在类中添加一个方法 iterator() 并返回一个迭代器 Iterator<Item>。迭代器都是泛型的，因此我们可以使用参数类型 Item 来帮助用例遍历它们指定的任意类型的对象。对于一直使用的数组表示法，我们需要逆序迭代遍历这个数组，因此我们将迭代器命名为 ReverseArrayIterator，并添加了以下方法：

```
public Iterator<Item> iterator()
{
  return new ReverseArrayIterator();
}
```

迭代器是什么？它是一个实现了 hashNext()和next()方法的类的对象，由以下接口所定义（即java.util.Iterator）：

```
public interface Iterator<Item>
{
  boolean hasNext();
  Item next();
  void remove();
}
```

尽管接口指定了一个 remove() 方法，但在本书中 remove() 方法总为空，因为我们希望避免在迭代中穿插能够修改数据结构的操作。对于 ReverseArrayIterator，这些方法都只需要一行代码，它们实现在栈类的一个嵌套类中：

```
private class ReverseArrayIterator implements Iterator<Item>
{
  private int i = N;
  public boolean hasNext() { return i > 0; }
  public Item next() { return a[--i]; }
  public void remove() {}
}
```

请注意，嵌套类可以访问包含它的类的实例变量，在这里就是 a[] 和 N（这也是我们使用嵌套类实现迭代器的主要原因）。从技术角度来说，为了和 Iterator 的结构保持一致，我们应该在两种情况下抛出异常：如果用例调用了 remove() 则抛出 UnsupportedOperationException，如果用例在调用 next() 时 i 为 0 则抛出 NoSuchElementException。因为我们只会在 foreach 语法中使用迭代器，这些情况都不会出现，所以我们省略了这部分代码。此外，我们还需要导入头文件：

```
import java.util.Iterator;
```

**ResizingArrayQueue的测试用例的轨迹**

![image.png](https://upload-images.jianshu.io/upload_images/4164292-9549f5e9270d0bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们在实现 Queue 的API时，可以使用两个实例变量作为索引，一个变量 head 指向队列的开头，一个变量 tail 指向队列的结尾，如表1.3.6所示。在删除一个元素时，使用 head 访问它并将 head 加 1；在插入一个元素时，使用 tail 保存它并将 tail 加 1。如果某个索引在增加之后越过了数组的边界则将它重置为0.

在算法的学习中，算法1.1十分重要，因为它几乎（但还没有）达到了任意集合类数据类型的实现的最佳性能：

* 每项操作的用时都与集合大小无关；
* 空间需求总是不超过集合大小乘以一个常数。

ResizingArrayQueue 的缺点在于某些 push() 和 pop() 操作会调整数组的大小：这项操作的耗时和栈大小成正比。

下面我们将学习一种克服该缺陷的方法，使用一种完全不同的方式来组织数据。

### 算法1.1 下压(LIFO)栈 （能够动态调整数组大小的实现）

```
import java.util.Iterator;
public class ResizingArrayStack<Item> implements Iterable<Item>
{
  private Item[] a = (Item[]) new Object[1]; // 栈元素
  private int N = 0; //元素数量
  public boolean isEmpty() { return N == 0; }
  public int size() { return N; }
  
  private void resize(int max)
  {
    // 将栈移动到一个大小为max 的新数组
    Item[] temp = (Item[]) new Object[max];
    for (int i = 0; i < N; i++)
      temp[i] = a[i];
    a = temp;
  }
  public void push(Item item)
  {
    // 将元素添加到栈顶
    if (N == a.length) resize(2*a.length);
    a[N++] = item;
  }
  public Item pop() 
  {
    // 从栈顶删除元素
    Item item = a[--N];
    a[N] = null; //避免对象游离（详见1.3.2.4节）
    if (N > 0 && N == a.length/4) resize(a.length/2);
    return item;
  }
  public Iterator<Item> iterator()
  { return new ReverseArrayIterator(); }
  private class ReverseArrayIterator implements Iterator<Item>
  {
    // 支持后进先出的迭代
    private int i = N;
    public boolean hasNext() { return i > 0 }
    public Item next() { return a[--i]; }
    public void remove() {}
  }
}
```

这份泛型的可迭代的 Stack API 的实现是所有集合类抽象数据类型实现的模板。它将所有元素保存在数组中，并动态调整数组的大小和栈大小之比小于一个常数。

### 1.3.3 链表

链表是一种基础数据结构，它是在集合类的抽象数据类型实现中表示数据的合适选择。链表的实现将成为其他更加复杂的数据结构的构造代码的模板。

**链表的定义**：链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。

在这个定义中，结点是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。和递归程序一样，递归数据结构的概念一开始也令人费解，但其实它的简洁性赋予了它巨大的价值。

#### 1.3.3.1 结点记录

在面向对象编程中，实现链表并不困难。我们首先用一个嵌套类来定义结点的抽象数据类型：

```
private class Node
{
  Item item;
  Node next;
}
```

一个 Node 对象含有两个实例变量，类型分别为 Item（参数类型）和 Node。我们会在需要使用 Node 类的类中定义它并将它标记为 private，因为它不是为用例准备的。和任意数据类型一样，我们通过 new Node() 触发（无参数）构造函数来创建一个 Node 类型的对象。调用的结果是一个指向 Node 对象的引用，它的实例变量均被初始化为 null。Item 是一个占位符，表示我们希望用链表处理的任意数据类型（我们将会使用 Java 的泛型使之表示任意引用类型）；

Node类型的实例变量显示了这种数据结构的链式本质。为了强调我们在组织数据时只使用了 Node 类，我们没有定义任何方法且会在代码中直接引用实例变量：如果 first是一个指向某个Node对象的变量，我们可以使用 first.item 和 first.node 访问它的实例变量。这种类型的类有时也被称为记录。它们实现的不是抽象数据类型因为我们会直接使用其实例变量。但是在我们的实现中，Node 和它的用例代码都会被封装在相同的类中且无法被该类的用例访问，所以我们仍然能够享受数据抽象的好处。

#### 1.3.3.2 构造链表

现在，根据递归定义，我们只需要一个 Node 类型的变量就能表示一条链表，只要保证它的值是 null 或者指向另一个 Node 对象且该对象的next域指向了另一条链表即可。

例如要构造一条含有元素 to、be和or的链表，我们首先为每个元素创造一个结点：

```
Node first = new Node();
Node second = new Node();
Node third = new Node();
```

并将每个结点的 item 域设为所需的值（简单起见，我们假设在这些例子中 Item 为 String）：

```
first.item = "to";
second.item = "be";
third.item = "or";
```

然后设置 next 域来构造链表：

```
first.next = second;
second.next = third;
```

注意，third.next 仍然是 null，即对象创建时它被初始化的值。

third 是一条链表（它是一个结点的引用，该结点指向 null，即一个空链表），second 也是一条链表（它是一个结点的引用，且该结点含有一个指向 third 的引用，而third是一条链表），first也是一条链表（它是一个结点的引用，且该结点含有一个指向 second 的引用，而 second 是一条链表）。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-a3579afe5260514c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

链表表示的是一列元素。在上面的例子中，first 表示的序列是 to、be、or。我们也可以用一个数组表示一列元素。例如，可以用以下数组表示同一列字符串：

```
String[] s = {"to", "be", "or"};
```

不同之处在于，在链表中向序列插入元素或是从序列中删除元素都更方便。

在追踪使用链表和其他链式结构的代码时，我们会使用可视化表示方法：

* 用长方形表示对象；
* 将实例变量的值写在长方形中；
* 用指向被引用对象的箭头表示引用关系。

这种表示方式抓住了链表的关键特性。方便起见，我们用术语“链接”表示对结点的引用。

#### 1.3.3.3 在表头插入结点

![image.png](https://upload-images.jianshu.io/upload_images/4164292-97ff4221bf51b0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

首先，假设你希望向一条链表中插入一个新的结点。最容易做到这一点的地方就是链表的开头。例如，要在首结点为 first 的给定链表开头插入字符串 not，我们先将 first 保存在 oldfirst中，然后将一个新结点赋予 first，并将它的 item 域设为 not，next 域设为 oldfirst。以上过程如图 1.3.6所示。这段在链表开头插入一个结点的代码只需要几行赋值语句，所以它所需的时间和链表长度无关。

#### 1.3.3.4 从表头删除结点

接下来，假设你希望删除一条链表的首结点。这个操作更简单：只需将 first 指向 first.next即可。一般来说，你可能会希望在赋值之前得到该元素的值，因为一旦改变了 first 的值，就再也无法访问它曾经指向的结点了。曾经的结点对象变成了一个孤儿，Java 的内容管理系统最终将回收它所占用的内存。和以前一样，这个操作只含有一条赋值语句，因此它的运行时间和链表的长度无关。此过程如图 1.3.7 所示。

#### 1.3.3.5 在表尾插入结点

如何才能在链表的尾部添加一个新结点？要完成这个任务，我们需要一个指向链表最后一个结点的链接，因为该结点的链接必须被修改并指向一个含有新元素的新结点。我们不能在链表代码中草草地决定维护一个额外的链接，因为每个修改链表的操作都需要添加检查是否要修改该变量（以及作出相应修改）的代码。例如，我们刚刚讨论过的删除链表首结点的代码就可能改变指向链表的尾结点的引用，因为当链表中只有一个结点时，它既是首结点又是尾结点。另外，这段代码也无法处理链表为空的情况（它会使用空链接）。类似这些情况的细节使链表代码特别难以调试。在链表结尾插入新结点的过程如图1.3.8所示。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c7f725cb3e9c1b4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.3.3.6 其他位置的插入和删除操作

总的来说，我们已经展示了在链表中如何通过若干指令实现以下操作，其中我们可以通过 first 链接访问链表的首结点并通过last 链接访问链表的尾结点：

* 在表头插入结点；
* 在表头删除结点；
* 在表尾插入结点。

其他操作，例如以下几种，就不那么容易实现了：

* 删除指定的结点；
* 在指定结点前插入一个新结点。

例如，我们怎样才能删除链表的尾结点呢？ last 链接帮不上忙，因为我们需要将链表尾结点的前一个结点中的链接（它指向的正是 last）值改为 null。在缺少其他信息的情况下，唯一的解决办法就是遍历整条链表并找出指向 last 的结点。这种解决方案并不是我们想要的，因为它所需的时间和链表的长度成正比。**实现任意插入和删除操作的标准解决方法是使用双向链表**，其中每个结点都含有两个链接，分别指向不同的方向。我们将实现这些操作的代码留做练习（请见练习1.3.31）。

#### 1.3.3.7 遍历

要访问一个数组中的所有元素，我们会使用如下代码来循环处理 a[] 中的所有元素：

```
for (int i = 0; i < N; i++)
{
  // 处理 a[i]
}
```

访问链表中的所有元素也有一个对应的方式：将循环的索引变量 x 初始化为链表的首结点，然后通过 x.item 访问和 x 相关联的元素，并将 x 设为 x.next 来访问链表中的下一个结点，如此反复直到 x 为 null 为止（这说明我们已经到达了链表的结尾）。这个过程被称为**链表的遍历**，可以用以下循环处理链表的每个结点的代码简洁表达，其中 first 指向链表的首结点：

```
for (Node x = first; x != null; x = x.next)
{
  //处理 x.item
}
```

这种方式和迭代遍历一个数组中的所有元素的标准方式一样自然。在我们的实现中，它是迭代器使用的基本方式。它使用例能够迭代访问链表的所有元素而无需知道链表的实现细节。

#### 1.3.3.8 栈的实现  2020.04.01

有了这些预备知识，给出我们的 Stack API 的实现就很简单了，如 94 页的算法 1.2 所示。它将栈保存为一条链表，栈的顶部即为表头，实例变量 first 指向栈顶。这样，当使用 push() 压入一个元素时，我们会按照 1.3.3.3节所讨论的代码将该元素添加在表头；当使用 pop() 删除一个元素时，我们会按照 1.3.3.4 节讨论的代码将该元素从表头删除。要实现 size() 方法，我们用实例变量 N 保存元素个数，在压入元素时将 N 加 1，在弹出元素时将 N 减 1。要实现 isEmpty() 方法，只需检查 first 是否为 null（或者可以检查 N 是否为 0）。该实现使用了泛型的 Item。你可以认为类名后的<Item>表示的是实现中所出现的所有 Item 都会替换为用例所提供的任意数据类型的名称（详见 1.3.2.2 节）。图1.3.9显示了我们所常用的测试用例的轨迹。
  
![image.png](https://upload-images.jianshu.io/upload_images/4164292-4adec594b268f7d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

链表的使用达到了我们最优设计目标：

* 它可以处理任意类型的数据；
* 所需的空间总是和集合的大小成正比；
* 操作所需的时间总是和集合的大小无关。

**Stack的测试用例**

```
public static void main(String[] args)
{
  // 创建一个栈并根据 StdIn中的指示压入或弹出字符串
  Stack<String> S = new Stack<String>();
  while (!StdIn.isEmpty())
  {
    String item = StdIn.readString();
    if (!item.equals("-"))
      s.push(item);
    else if (!s.isEmpty())  StdOut.print(s.pop() + " ");
  }
  StdOut.println("("+ s.size() +" left on stack)");
}
```

这份实现是我们对许多算法的实现的原型。它定义了链表数据结构并实现了供用例使用的方法 push() 和 pop()，仅用了少量代码就取得了所期望的效果。算法和数据结构是相辅相成的。在本例中，算法的实现代码很简单，但数据结构的性质却并不简单，我们用了好几页纸来说明这些性质。这种数据结构的定义和算法的实现的相互作用很常见，也是本书中我们对抽象数据类型的实现重点。
  
### 算法1.2 下压堆栈 （链表实现）

```
public class Stack<Item> implements Iterable<Item>
{
  private Node first; // 栈顶（最近添加的元素）
  private int N; // 元素数量
  private class Node
  {
    // 定义了结点的嵌套类
    Item item;
    Node next;
  }
  public boolean isEmpty() { return first == null; } // 或： N == 0
  public int size() { return N; }
  public void push(Item item)
  {
    // 向栈顶添加元素
    Node oldfirst = first;
    first = new Node();
    first.item = item;
    first.next = oldfirst;
    N++;
  }
  public Item pop()
  {
    //从栈顶删除元素
    Item item = first.item;
    first = first.next;
    N--;
    return item;
  }
  // iterator() 的实现详见算法 1.4
  // 测试用例 main() 的实现请见本节前面部分
}
```

这份泛型的 Stack 实现的基础是链表数据结构。它可以用于创建任意数据类型的栈。要支持迭代，请添加算法1.4中为Bag数据类型给出的加粗部分的代码。

#### 1.3.3.9 队列的实现

基于链表数据结构实现 Queue API 也很简单，如算法 1.3 所示。它将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量 first 指向队列的开头，实例变量 last 指向队列的结尾。这样，要将一个元素入列（enqueue()），我们就将它添加到表尾（详见图 1.3.8 中讨论的代码，但是在链表为空时需要将 first 和 last 都指向新结点）；要将一个元素出列（dequeue()），我们就删除表头的结点（代码和 Stack 的 pop() 方法相同，只是当链表为空时需要更新last的值）。size() 和 isEmpty() 方法的实现和 Stack 相同。和 Stack 一样，Queue 的实现也使用了泛型参数 Item。这里我们省略了支持迭代的代码并将它们留到算法 1.4 中继续讨论。

下面所示的是一个开发用例，它和我们在 Stack 中使用的用例很相似，它的轨迹如算法 1.3 所示。Queue 的实现使用的数据结构和 Stack 相同，都是链表，但它实现了不同的添加和删除元素的算法，这也是用例所看到的后进先出和先近后出的区别所在。和刚才一样，我们用链表达到了最优设计目标：它可以处理任意类型的数据，所需的空间总是和集合的大小成正比，操作所需的时间总是和集合的大小无关。

**Queue的测试用例**：

```
public static void main(String[] args)
{
  // 创建一个队列并操作字符串入列或出列
  Queue<String> q = new Queue<String>();
  while (!StdIn.isEmpty())
  {
    String item = StdIn.readString();
    if (!item.equals("-"))
      q.enqueue(item);
    else if (!q.isEmpty()) StdOut.print(q.dequeue() + " ");
  }
  StdOut.println("(" + q.size() + " left on queue)");
}
```

```
% more tobe.txt
to be or not to - be - - that - - - is

% java Queue < tobe.txt
to be or not to be (2 left on queue)
```

![image.png](https://upload-images.jianshu.io/upload_images/4164292-878c7aa5615d7708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 算法 1.3 先进先出队列

```
public class Queue<Item> implements Iterable<Item>
{
  private Node first; //指向最早添加的终点的链接
  private Node last; //指向最近添加的终点的链接
  private int N; // 队列中的元素数量
  private class Node
  {
    // 定义了结点的嵌套类
    Item item;
    Node next;
  }
  public boolean isEmpty() { return first == null; } // 或： N == 0
  public int size() { return N; }
  public void enqueue(Item item)
  {
    
  }
}
```



