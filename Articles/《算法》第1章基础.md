# 算法 第1章 基础

本书的目的是研究多种重要而实用的算法，即适合用计算机实现的解决问题的方法。和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。本章介绍的就是学习算法和数据结构所需要的基本工具。

首先要介绍的是基础编程模型。接下来重点介绍的是数据抽象并定义抽象数据类型（ADT）以进行模块化编程。接下来将学习三种基础的抽象数据类型：背包、队列和栈。1.3节用数组、变长数组和链表实现了背包、队列和栈的 API，它们是全书算法实现的起点和样板。**性能是算法研究的一个核心问题**。1.4节描述了分析算法性能的方法。我们的基本做法是科学式的，即先对性能提出假设，建立数学模型，然后用多种实验验证它们，必要时重复这个过程。

### 算法

在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。算法是计算机科学的基础。是这个领域研究的核心。数据结构是算法的副产品或是结果，因此要理解算法必须学习数据结构。简单的算法也会产生复杂的数据结构，相应地，复杂的算法也许只需要简单的数据结构。

当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的不同并没有什么关系。但是**对于大型问题（或者是需要解决大量小型问题的应用），我们就需要设计能够有效利用时间和空间的方法了**


**学习算法的主要原因是它们能节约非常多的资源，甚至能够让我们完成一些本不可能完成的任务。在某些需要处理上百万个对象的应用程序中，设计优良的算法甚至可以将程序运行的速度提高数百万倍。与此相反，花金钱和时间去购置新的硬件可能只能将速度提高十倍或是百倍。无论在任何应用领域，精心设计的算法都是解决大型问题最有效的方法**。

学习算法是非常有趣和令人激动的，因为这是一个历久弥新的领域。这个领域不断有新的发现，但研究透彻的算法仍然是少数。本书中既有精巧、复杂和高难度的算法，也有优雅、朴素和简单的算法。在科学和商业应用中，我们的目标是理解前者并熟悉后者，这样才能掌握这些有用的工具并学会算法式思考，以迎接未来计算任务的挑战。

### 1.1 基础编程模型

我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为**基础编程模块**。

### 1.1.1 Java程序的基本结构

要创建静态方法库和定义数据类型，会用到下面五种语法，它们是 Java 语言的基础，也是大多数现代语言所共有的。

* **原始数据类型**:它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。
* **语句**：语句通过创建变量并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：声明、赋值、条件、循环、调用和返回。
* **数组**：数组是多个同种数据类型的值的集合。
* **静态方法**：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。
* **字符串**：字符串是一连串的字符，Java 内置了对它们的一些操作。
* **标准输入/输出**：标准输入输出是程序与外界联系的桥梁。
* **数据抽象**：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。

#### Java程序及其命令行的调用

```
import java.util.Arrays;//导入一个java库
//代码文件名必须是 BinarySearch.java
public class BinarySearch
{
  //静态方法
  public static int rank(int key, int[] a)
  {
    int lo = 0;//初始化声明语句
    int hi = a.lenght - 1;
    while (lo <= hi)
    {
      int mid = lo + (hi - lo) / 2;
      if (key < a[mid]) hi = mid - 1;
      else if (key > a[mid]) lo = mid + 1;
      else return mid;
    }
    return -1;
  }
  
  public static void main(String[] args)
  {
    int[] whitelist = In.readInts(args[0]);
    Arrays.sort(whitelist);//调用Java库中的sort方法
    while (!StdIn.isEmpty())
    {
      //isEmpty方法和readInt方法：调用标准库中的方法
      int key = StdIn.readInt();
      if (rank(key, whitelist) == -1)
        StdOut.println(key);
    }
  }
}
```

### 1.1.2 原始数据类型与表达式

4种Java语言最基本的原始数据类型（Java语言内置的原始数据类型）：

* 整型（int），及其算术运算符；
* 浮点型（double），及其算术运算符；
* 布尔型（boolean），它的值 {true, false}及其逻辑操作；
* 字符型（char），它的值是你能够输入的英文字母数字字符和符号

![Java 程序的基本组成](https://upload-images.jianshu.io/upload_images/4164292-43a26749120c22aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对于原始类型来说，我们用标识符来引用变量，用+、-、* 、/ 等运算符来指定操作，用字面量，例如1或者3.14来表示值。

### 1.1.2.1 运算符优先级

运算符优先级：**运算符 * 和 /(以及%)的优先级高于 + 和 -（优先级越高，越早运算）；在逻辑运算符中，!拥有最高优先级，之后是 &&，接下来是 ||。一般来说，相同优先级的运算符的运算顺序是从左到右。与在正常的算数表达式中一样，使用括号能够改变这些规则**。

### 1.1.2.2 类型转换

如果不会损失信息，数值会被自动提升为高级的数据类型。例如，在表达式 1+2.5 中，1 会被转换为浮点数1.0，表达式的值也为double值3.5。转换指的是在表达式中把类型名放在括号里将其后的值转换为括号中的类型。例如，(int)3.7的值是3而(double)3的值是3.0。需要注意的是将浮点类型转换为整型将会截断小数部分而非四舍五入，在复杂的表达式中的类型转换可能会很复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。

### 1.1.2.3 比较

下列运算符能够比较相同数据类型的两个值并产生一个布尔值：相等（==）、不等（!=）、小于（<）、小于等于（<=）、大于（>）和大于等于（>=）。这些运算符被称为混合类型运算符，因为它们的结果是布尔型，而不是参与比较的数据类型。结果是布尔型的表达式被称为布尔表达式。我们将会看到这种表达式是条件语句和循环语句的重要组成部分。


### 1.1.2.4 其他五种原始类型

Java的整型能够表示 2<sup/>32</sup>个不同的值，用一个32位二进制即可表示（虽然现在的许多计算机有64位二进制，但整型仍然是32位）。与此相似，浮点型的标准规定为64位。这些大小对于一般应用程序中使用的整数和实数已经足够了。为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：

* 64位整数，及其算术运算符（long）；
* 16位整数，及其算术运算符（short）；
* 16位字符，及其算数运算符（char）；
* 8位整数，及其算术运算符（byte）；
* 32位单精度实数，及其算数运算符（float）；

### 1.1.3 语句

Java 程序是由语句组成的。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。

* 声明语句：创建某种类型的变量并用标识符为其命名。声明语句用来指定变量的名称和类型。Java是一种强类型的语言，所以 Java 编译器会检查类型的一致性（例如，它不会允许将布尔类型和浮点类型的变量相乘）。变量可以声明在第一次使用之前的任何地方。一般我们都在首次使用该变量时声明它。变量的作用域就是定义它的地方，一般由相同代码段中声明之后的所有语句组成。
* 赋值语句：将（由表达式产生的）某种类型的数值赋予一个变量。赋值语句的左侧必须是单个变量，右侧可以是能够得到相应类型的值的任意表达式。
* 条件语句：根据指定的条件执行两个代码段之一。比如 if语句
* 循环语句：只要条件为真就不断地反复执行代码段中的语句。比如 while语句
* 调用和返回语句：和静态方法有关，是改变执行流程和代码组织的另一种方式。比如Java 支持在 while 循环中使用 break语句和 continue 语句。break 语句表示立即从循环中退出；continue 语句表示立即结束本次循环并开始下一轮循环。

程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。一般来说代码的结构都是嵌套的：一个条件语句或循环语句的代码中也能包含条件语句或是循环语句。

### 1.1.4 简便记法

程序有很多中写法，我们追求清晰、优雅和高效的代码。这样的代码经常会使用以下这些广为流传的简便写法：

* 声明并初始化：可以将声明语句和赋值语句结合起来，在声明（创建）一个变量的同时将它初始化。最好在接近首次使用变量的地方声明它并将其初始化（为了限制它的作用域）。
* 隐式赋值：当希望一个变量的值相对于其当前值变化时，可以使用下面一些简便的写法。（1）递增/递减运算符：++i; 等价于 i=i+1;且表达式的值为 i+1;。类似地，--i;等价于 i=i-1; i++ 和 ++i 的不同在于 i++; 表达式的值为i。（2）其他复合运算符：i/=2;等价于 i=i/2; 注意，i += 1;等价于 i = i + 1;（以及 ++i;）。
* 单语句代码段：如果条件或循环语句的代码段只有一条语句，代码段的花括号可以省略。

![Java语句总结.png](https://upload-images.jianshu.io/upload_images/4164292-a0a41924d28e4ee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.5 数组

数组能够**顺序存储相同类型的多个数据**。在 Java 代码中用 a[i]来访问数组a的第i个元素的值。在 Java 中这种数组被称为**一维数组**。

#### 1.1.5.1 创建并初始化数组

在 Java 程序中创建一个数组需要三步：
* (1)声明数组的名字和类型。在声明数组时，需要指定数组的名称和它含有的数据类型。 
* (2)创建数组。在创建数组时，需要指定数组的长度（元素的个数）。
* (3)初始化数组元素。

```
//(1)完整写法：
double[] a;//声明数组
a = new double[N];//创建数组
for (int i = 0; i < N; i++)
  a[i] = 0.0;//初始化数组
  
//(2)简化写法：
double[] a = new double[N];

//(3)声明初始化（声明、创建并初始化一个数组）：在编译时将数组初始化
int[] a = { 1, 1, 2, 3, 5, 8 };
```

【注意】我们需要在运行时明确地创建数组的原因是 Java 编译器在编译时无法知道应该为数组预留多少空间（对于原始类型则可以）。

#### 1.1.5.2 简化写法

为了精简代码，我们常常会利用 Java 对数组默认的初始化来将三个步骤合为一条语句。即：

```
double[] a = new double[N];
```

等号的左边声明了数组，等号的右边创建了数组。这种写法不需要for循环，因为在一个 Java 数组中 double 类型的变量的默认初始值都是0.0，但如果你想使用不同的初始值，那么就需要使用 for 循环了。数组类型的默认初始值是0，布尔型的默认初始值是 false。

#### 1.1.5.3 使用数组

在声明并创建数组之后，在代码的任何地方都能通过数组名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是固定的。程序能够通过 a.length 获取数组 a[] 的长度，而它的最后一个元素总是 a[a.length - 1]。Java会自动进行边界检查。如果你创建了一个大小为N的数组，但使用了一个小于0或者大于N-1 的索引访问它，程序会因为运行时抛出 ArrayOutOfBoundsException 异常而终止。

#### 典型的数组处理代码

* (1)找出数组a中最大的元素：

```
double max = a[0];
for (int i = 1; i < a.length; i++)
  if (a[i] > max) max = a[i];
```
* (2)计算数组元素的平均值：

```
int N = a.length;
double sum = 0.0;
for (int i = 0; i < N; i++)
  sum += a[i];
double average = sum / N;
```
* (3)复制数组：

```
int N = a.length;
double[] b = new double[N];
for (int i = 0; i < N; i++)
  b[i] = a[i];
```

* (4)颠倒数组元素的顺序：

```
int N = a.length;
for (int i = 0; i < N/2; i++)
{
  double temp = a[i];
  a[i] = a[N-1-i];
  a[N-i-1] = temp;
}
```

* (5)矩阵相乘（方阵）a[][] * b[][] = c[][]

```
int N = a.length;
double[][] c = new double[N][N];
for (int i = 0; i < N; i++)
  for (int j = 0; j < N; j++)
  {
    // 计算行 i 和列 j 的点乘
    for (int k = 0; k < N; k++)
      c[i][j] += a[i][k] * b[k][j];
  }
```

### 1.1.5.4 起别名

数组名表示的是整个数组，如果我们将一个数组变量赋值给另一个变量，那么两个变量将会指向同一个数组。

```
int[] a = new int[N];
...
a[i] = 1234;
int[] b = a;
...
b[i] = 5678;//a[i]的值也会变成 5678
```

上例中 a[i]的值也会变为 5678，这种情况叫做起别名，有时可能会导致难以觉察的问题。如果你是想将数组复制一份，那么应该声明、创建并初始化一个新的数组，然后将原数组中的元素值挨个复制到新数组。

### 1.1.5.5 二维数组

在 Java 中二维数组就是一维数组的数组。二维数组可以是参差不齐的（元素数组的长度可以不一致），但大多数情况下我们都会使用 M * N，即 M 行长度为 N 的数组的二维数组（也可以称数组含有N列）。在 Java 中访问二维数组 a[][] 的第 i 行第 j 列的元素可以写作 a[i][j]。声明二维数组需要两对方括号。创建二维数组时要在类型名之后分别在方括号中指定行数以及列数。

```
double[][] a = new double[M][N];
```

我们将这样的数组称为 M * N 的数组。我们约定，第一维是行数(M行)，第二维是列数(N列)。和一维数组一样，Java会将数值类型的数组元素初始化为0，将布尔型的数组元素初始化为false。默认的初始化对二维数组更有用，因为可以节约更多的代码。下面这段代码和刚才只用一行就完成创建和初始化的语句是等价的：

```
double[][] a;
a = new double[M][N];
for (int i = 0; i < M; i++)
  for (int j = 0; j < N; j++)
    a[i][j] = 0.0;
```

【注意】在将二维数组初始化为0时这段代码是多余的，但是如果想要初始化为其他值，我们就需要嵌套的 for 循环了。

### 1.1.6 静态方法

在许多语言中，静态方法被称为函数，因为它们和数学函数的性质类似。静态方法是一组在被调用时会被顺序执行的语句。修饰符 static 将这类方法和 1.2节中的实例方法区别开来。

#### 1.1.6.1 静态方法

方法封装了由一系列语句所描述的运算。方法需要参数并根据参数计算出某种数据类型的返回值或产生某种副作用（例如打印一个值）。每个静态方法都是由签名（关键字public static 以及函数的返回值，方法名以及一串各种类型的参数）和函数体（即包含在花括号中的代码）组成的。

![静态方法解析.png](https://upload-images.jianshu.io/upload_images/4164292-1cd5f255e5ddbc5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 典型静态方法的实现（绝对值、素数、平方根、三角形斜边、调和级数）

* 计算一个整数的绝对值：

```
public static int abs(int x)
{
  if (x < 0) return -x;
  else       return x;
}
```

* 计算一个浮点数的绝对值：

```
public static double abs(double x)
{
  if (x < 0.0) return -x;
  else         return x;
}
```

* 判定一个数是否是素数：

```
public static boolean isPrime(int N)
{
  if (N < 2) return false;
  for (int i = 2; i*i <= N; i++)
    if (N % i == 0) return false;
  return true;
}
```

* 计算平方根（牛顿迭代法）：

```
public static double sqrt(double c)
{
  if (c < 0) return Double.NaN;
  double err = le-15;
  double t = c;
  while (Math.abs(t - c/t) > err * t)
    t = (c/t + t) / 2.0;
  return t;
}
```

* 计算直角三角形的斜边：

```
public static double hypotenuse(double a, double b)
{
  return Math.sqrt(a*a + b*b);
}
```

* 计算调和级数：

```
public static double H(int N)
{
  double sum = 0.0;
  for (int i = 1; i <= N; i++)
    sum += 1.0 / i;
  return sum;
}
```

#### 1.1.6.2 调用静态方法

调用静态方法是写出方法名并在后面的括号中列出参数值，用逗号分隔。当调用是表达式的一部分时，方法的返回值将会替代表达式中的方法调用。例如，BinarySearch中调用 rank() 返回了一个int值。仅由一个方法调用和一个分号组成的语句一般用于产生副作用。例如，BinarySearch的 main() 函数中对系统方法 Arrays.sort()的调用产生的副作用，是将数组中的所有条目有序地排列。调用方法时，它的参数变量将被初始化为调用时所给出的相应表达式的值。返回语句将结束静态方法并将控制权交还给调用者。如果静态方法的目的是计算某个值，返回语句应该指定这个值（如果这样的静态方法在执行完所有的语句之后都没有返回语句，那么编译器会报错）。

#### 1.1.6.3 方法的性质

* 方法的参数按值传递
* 方法名可以被重载
* 方法只能返回一个值，但可以包含多个返回语句
* 方法可以产生副作用：方法的返回值可以是void，这表示该方法没有返回值。返回值为void的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回给调用方。

#### 1.1.6.4 递归

递归是指方法可以调用自己。使用递归可以使代码更简洁优雅、易懂。编写递归代码时最重要的有以下三点：

* 递归总有一个最简单的情况，方法的第一条语句总是一个包含return的条件语句
* 递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。在下面的代码中，第四个参数和第三个参数的差值一直在缩小。
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。在下面的代码中，两个子问题各自操作的数组部分是不同的。

**二分查找的递归实现**

```
public static int rank(int key, int[] a)
{
  return rank(key, a, 0, a.length - 1);
}
public static int rank(int key, int[] a, int lo, int hi)
{
  //如果key存在于a[]中，它的索引不会小于lo且不会大于hi
  if (lo > hi) return -1;
  int mid = lo + (hi - lo) / 2;
  if (key < a[mid]) return rank(key, a, lo, mid - 1);
  else if (key > a[mid]) return rank(key, a, mid + 1, hi);
  else return mid;
}
```

违背其中任意一条都可能得到错误的结果或是低效的代码，而坚持这些原则能写出清晰、正确且容易评估性能的程序。使用递归的一个原因是递归代码比相应的非递归代码更加简洁优雅、易懂。另一个原因是我们可以使用数学模型来估计程序的性能。我们会在3.2节的二分查找以及其他几个地方分析这个问题。

#### 1.1.6.5 基础编程模型

静态方法库是定义在一个 Java 类中的一组静态方法。类的声明是public class 加上类名，以及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是.java。Java开发的基本模式是编写一个静态方法库（包含一个main()方法）来完成一个任务。输入 java 和类名以及一系列字符串就能调用类中的main()方法，其参数为由输入的字符串组成的一个数组。main()的最后一条语句执行完毕后程序终止。

#### 1.1.6.6 模块化编程

这个模型的最重要之处在于通过静态方法库实现了模块化编程。我们可以构造许多个静态方法库（模块），一个库中的静态方法也能够调用另一个库中的定义的静态方法。这能够带来许多好处：

* 程序整体的代码量很大时，每次处理的模块大小仍然适中；
* 可以共享和重用代码而无需重新实现；
* 很容易用改进的实现替换老的实现；
* 可以为解决编程问题建立合适的抽象模型；
* 缩小调试范围。

#### 1.1.6.7 单元化测试

Java编程的最佳实践之一就是每个静态方法库中都包含一个 main()函数来测试库中的所有方法（有些编程语言不支持多个main()方法，因此不支持这种方式）。恰当的单元测试本身也是很有挑战的编程任务。每个模块的main()方法至少应该调用模块中的其他代码并在某种程度上保证它的正确性。随着模块的成熟，我们可以将main()方法作为一个开发实例，在开发过程中用它来测试更多的细节；也可以把它编成一个测试用例来对所有代码进行全面的测试。当用例越来越复杂时，我们可能会将它独立成一个模块。

#### 1.1.6.8 外部库

* 系统标准库 java.lang.* ：这其中包括 Math 库，实现了常用的数学函数；Integer 和 Double 库，能够将字符串转化为 int 和 double 值；String 和 StringBuilder 库、System。
* 导入的系统库。例如java.utils.Arrays
* 其他库

要调用另一个库中的方法（存放在相同或指定的目录中，或是一个系统标准库，或是在类定义前用 import 语句导入的库），我们需要在方法前指定库的名称。例如，BinarySearch 的 main() 方法调用了系统库 java.utils.Arrays 的 sort() 方法，StdIn 库中的 readInts() 方法和 StdOut库中的 println() 方法。

### 1.1.7 API

#### 1.1.7.1 Java 数学函数库部分函数

![Java数学函数库部分函数.png](https://upload-images.jianshu.io/upload_images/4164292-d0d3ce83d581bd80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.7.2 Java 库

对于某些基础算法，可以自己实现，当然也可以使用高度优化的库直接调用。

#### 1.1.7.3 我们的标准库

为了介绍 Java 编程、为了科学计算以及算法的开发、学习和应用，我们也开发了若干库来提供一些实用的功能。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-d24f1d502327a00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

以上有些方法的实现非常简单，为什么还要再方法库中实现它们？设计良好的方法库对这个问题的标准回答如下：

* 这些方法所实现的抽象层有助于我们将精力集中在实现和测试本书中的算法，而非生成随机数或是统计计算。每次都自己写相同计算的代码，不如直接在用例中调用它们更简洁易懂。
* 方法库会经过大量测试，覆盖极端和罕见的情况，是我们可以信任的。这样的实现需要大量的代码。例如我们经常需要使用的各种数据类型的实现，又比如Java的 Array库针对不同数据类型对 sort() 进行了多次重载。

因此建议到本书的网站上去学习一下 STDRandom.java 和 StdStats.java 的源代码并好好利用这些经过验证了的实现。使用这些库最简单的方法就是从网站上下载它们的源代码并放入你的工作目录。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f36b2608e2e2d60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.7.4 你自己编写的库

你应该将自己编写的每一个程序都当做一个日后可以重用的库。

* 编写用例，在实现中将计算过程分解成可控的部分。
* 明确静态方法库和与之对应的 API（或者多个库的多个API）
* 实现 API 和一个能够对方法进行独立测试的 main() 函数。

API 的目的是将调用和实现分离：除了API中给出的信息，调用者不需要知道实现的其他细节，而实现也不应考虑特殊的应用场景。API使我们能够广泛地重用那些为各种目的独立开发的代码。相应地，程序员也可以将 API 看作调用和实现之间的一份契约，它详细说明了每个方法的作用。

### 1.1.8 字符串

String 类型是 Java 的一个数据类型，但并不是原始数据类型。

#### 1.1.8.1 字符串拼接

Java 内置了一个串联 String 类型字符串的运算符（+）。

#### 1.1.8.2 类型转换

![image.png](https://upload-images.jianshu.io/upload_images/4164292-01dad084429bdcea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.8.3 自动转换

我们很少明确使用 toString()方法，因为 Java在连接字符串时会自动将任意数据类型的值转换为字符串：如果加号（+）的一个参数是字符串，那么Java会自动将其他参数转换为字符串。除了像“The square root of 2.0 is” + Math.sqrt(2.0)这样的使用方式之外，这种机制也使我们能够通过一个空字符串 "" 将任意数据类型的值转换为字符串值。

#### 1.1.8.4 命令行参数

在 Java 中字符串的一个重要的用途就是使程序能够接收到从命令行传递过来的信息。这种机制很简单。**当你输入命令 java和一个库名以及一系列字符串之后，Java 系统会调用库的main()方法并将那一系列字符串变成一个数组作为参数传递给它。例如，BinarySearch的main()方法需要一个命令行参数，因此系统会创建一个大小为1的数组。程序用这个值，也就是 args[0]，来获取白名单文件的文件名并将其作为 StdIn.readInts() 的参数。另一种在我们的代码中常用的用法是当命令行参数表示的是数字时，我们会用 parseInt() 和 parseDouble() 方法将其分别转换为整数和浮点数**。

### 1.1.9 输入输出

#### 1.1.9.1 命令和参数

终端窗口包含一个提示符，通过它我们能够向操作系统输入命令和参数。我们会经常使用 java 命令来运行我们的程序。Java 类都会包含一个静态方法 main()，它有一个 String 数组类型的参数 args[]。这个数组的内容就是我们输入的命令行参数，操作系统会将它传递给 java。Java和操作系统都默认参数为字符串。如果我们需要的某个参数是数字，我们会使用类似 Integer.parseInt() 的方法将其转换为适当的数据类型的值。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-fb46a261be3ffc84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.1.9.2 标准输出

![image.png](https://upload-images.jianshu.io/upload_images/4164292-fc2b4677710b858b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.3 格式化输出

![image.png](https://upload-images.jianshu.io/upload_images/4164292-7b2adf4b3e713aad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.1.9.4 标准输入

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f59945e64747f573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
public class Average
{
  public static void main(String[] args)
  {
    // 取StdIn中的所有数的平均数
    double sum = 0.0;
    int cnt = 0;
    while (!StdIn.isEmpty())
    {//读取一个数并计算累计之和
       sum += StdIn.readDouble();
       cnt++;
    }
    double avg = sum / cnt;
    StdOut.printf("Average is %.5f\n", avg);
  }
}
```

在终端输入：

```
% java Average 
1.23456
2.34567
3.45678
4.56789
//输出结果：
<ctrl-d>
Average is 2.90123
```

#### 1.1.9.5 重定向与管道

![命令行的重定向与管道.png](https://upload-images.jianshu.io/upload_images/4164292-1b99f348873f4666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.6 基于文件的输入输出

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8237edf50cdad2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.7 标准会图库（基本方法）

![标准绘图库的静态方法的API.png](https://upload-images.jianshu.io/upload_images/4164292-d98e5c7f45d35f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.9.7 标准绘图库（控制方法）

![image.png](https://upload-images.jianshu.io/upload_images/4164292-87ed187ed412ebfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

StdDraw 绘图举例：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8337e348b50cf0f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.1.10 二分查找

我们要学习的第一个 Java 程序的示例程序就是著名、高效且应用广泛的二分查找算法。具体 Java 代码实现如下：

```
import java.util.Arrays;//导入一个java库
//代码文件名必须是 BinarySearch.java
public class BinarySearch
{
  //静态方法
  public static int rank(int key, int[] a)
  {
    // 二分查找的数组必须是有序的
    int lo = 0;//初始化声明语句
    int hi = a.lenght - 1;
    while (lo <= hi)
    {//被查找的键要么不存在，要么必然存在于 a[lo..hi]之中
      int mid = lo + (hi - lo) / 2;
      if (key < a[mid]) hi = mid - 1;
      else if (key > a[mid]) lo = mid + 1;
      else return mid;
    }
    return -1;
  }
  
  public static void main(String[] args)
  {
    int[] whitelist = In.readInts(args[0]);
    Arrays.sort(whitelist);//调用Java库中的sort方法
    while (!StdIn.isEmpty())
    {
      //isEmpty方法和readInt方法：调用标准库中的方法
      // 读取键值，如果不存在于白名单中则将其打印
      int key = StdIn.readInt();
      if (rank(key, whitelist) == -1)
        StdOut.println(key);
    }
  }
}
```

```
% java BinarySearch tinyW.txt < tinyT.txt
50
99
13
```

这段程序接受了一个白名单文件（一列整数）作为参数，并会过滤掉标准输入中的所有存在于白名单中的条目，仅将不在白名单上的整数打印到标准输出中。它在rank()静态方法中实现了二分查找算法并高效地完成了这个任务。关于二分查找算法的完整讨论，包括它的正确性、性能分析及其应用，详见3.1节。

#### 1.1.10.1 二分查找原理

二分查找算法是由静态方法 rank() 实现的，它接受一个整数键和一个已经有序的int 数组作为参数。如果该键存在于数组中则返回它的索引，否则返回 -1。算法使用两个变量 lo 和 hi，并保证如果键在数组中则它一定在 a[lo..hi]中，然后方法进入一个循环，不断将数组中的中间键（索引为 mid）和被查找的键比较。如果被查找的键等于 a[mid]，则返回 mid；否则算法就将查找范围缩小一半，如果被查找的键小于 a[mid] 就继续在左半边查找，如果被查找的键大于 a[mid] 就继续在右半边查找。算法找到被查找的键或是查找范围为空时该过程结束。二分查找之所以快就是因为它只需检查很少几个条目（相对于数组的大小）就能够找到目标元素（或者确认目标元素不存在）。

#### 1.1.10.2 开发用例

在这个例子中，这个用例会从命令行指定的文件（tinyT.txt）中读取多个整数，并会打印出标准输入（tinyW.txt）中所有不存在于该文件中的整数。我们使用了图1.1.8所示的几个较小的测试文件来展示它的行为，这些文件也是图1.1.7中的跟踪和例子的基础。我们会使用较大的测试文件来模拟真实应用并测试算法的性能（详见1.1.10.3节）。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-dfeb3918bfe060f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.10.3 白名单过滤

如果可能，我们的测试用例都会通过模拟实际情况来展示当前算法的必要性。这里该过程被称为白名单过滤。具体来说，可以想象一家信用卡公司，它需要检查客户的交易账号是否有效。为此，它需要：

* 将客户的账号保存在一个文件中，我们称它为白名单；
* 从标准输入中得到每笔交易的账号；
* 使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易。

在一家有上百万客户的大公司中，需要处理数百万甚至更多的交易是很正常的。为了模拟这种情况，我们在本书网站上提供了文件 largeW.txt(100万个整数)和largeT.txt（1000万个整数），其基本情况如图1.1.9所示：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c0a1e3990c52af23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.1.10.4 性能

一个程序只是可用往往是不够的。例如，以下 rank() 的实现也可以很简单，它会检查数组的每个元素，甚至都不需要数组是有序的：

```
public static int rank(int key, int[] a) 
{
  for (int i = 0; i < a.lenght; i++)
    if (a[i] == key) return i;
   return -1;
}
```

有了这个简单易懂的解决方案，我们为什么还需要归并排序和二分查找呢？在练习1.1.38中可以看到计算机用 rank() 方法的暴力实现处理大量输入（比如含有100万个条目的白名单和1000万条交易）非常慢。如果不采用像二分查找或者归并排序这样的高效算法，是无法解决大规模的白名单问题的。良好的性能常常是极为重要的。因此我们会在1.4节中为性能研究做一些铺垫，并会分析我们学习的所有算法的性能特点（包括2.2节的归并排序和3.1节中的二分查找）。


## 1.2 数据抽象

数据抽象指的是一组值和一组对这些值的操作的集合。

Java编程的基础主要是使用 class 关键字构造被称为引用类型的数据类型。这种编程风格也称为面向对象编程。因为它的核心概念是对象，即保存了某个数据类型的值的实体。如果只有 Java 的原始数据类型，我们的程序会很大程度上被限制在算数计算上，但有了引用类型，我们就能编写操作字符串、图像、声音以及 Java 的标准库中或者本书的网站上的数百种抽象类型的程序。而且能够定义自己的数据类型来抽象任意对象。

抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型。

### 1.2.1 使用抽象数据类型

要使用一种数据类型并不一定非得知道它是如何实现的，所以我们首先来编写一个使用一种名为 Counter（计数器）的简单数据类型的程序。它的值是一个名称和一个非负整数，它的操作有创建对象并初始化为0，当前值加1和获取当前值。这个抽象对象在许多场景中都会用到。例如，这样一个数据类型可以用于电子机票软件，它能够保证投票者所能进行的唯一操作就是将他选择的候选人的计数器加1。我们也可以在分析算法性能时使用 Counter 来记录基本操作的调用次数。要使用 Counter 对象，首先需要了解应该如何定义数据类型的操作，以及在 Java 语言中应该如何创建和使用某个数据类型的对象。这些机制在现代编程中非常重要。

#### 1.2.1.1 抽象数据类型的 API

我们使用应用程序编程接口（API）来说明抽象数据类型的行为。它将列出所有构造函数和实例方法（即操作）并简要描述它们的功用。

抽象数据类型的定义和静态方法库之间有许多共同之处：

* 两者的实现均为 Java 类；
* 实例方法可能接受 0 个或者多个指定类型的参数，由括号表示并由逗号分隔；
* 它们可能会返回一个指定类型的值，也可能不会（用 void 表示）。

抽象数据类型的定义和静态方法库的三个不同：

* API中可能会出现若干个名称和类名相同且没有返回值的函数。这些特殊的函数被称为**构造函数**。在本例中， Counter 对象有一个接受一个 String 参数的构造函数。
* 实例方法不需要 static 关键字。它们不是静态方法，它们的目的就是操作该数据类型中的值。
* 某些实例方法的存在是为了尊重 Java 的习惯。我们将此类方法称为继承的方法并在 API 中将它们显示为灰色。

![计数器 Counter 的API.png](https://upload-images.jianshu.io/upload_images/4164292-896c292c5036dc8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


这份 API 告诉我们可以通过构造函数 Counter()、实例方法 increment() 和 tally()，以及继承的 toString() 方法使用 Counter 类型的对象。

#### 1.2.1.2 继承的方法

根据 Java 的约定，任意数据类型都能通过在 API中包含特定的方法从 Java 的内在机制中获益。例如，Java中的所有数据类型都会继承 toString() 方法来返回用 String 表示的该类型的值。Java 会在用 + 运算符将任意数据类型的值和 String 值连接时调用该方法。该方法的默认实现并不实用（它会返回用字符串表示的该数据类型值的内存地址），因此我们常常会提供实现来重载默认实现，并在此时在 API 中加上 toString() 方法。此类方法的例子还包括 equals()、compareTo() 和hashCode()等。

#### 1.2.1.3 用例代码

#### 1.2.1.4 对象

一般来说，可以声明一个变量 heads 并将它通过以下代码和 Counter 类型的数据关联起来：

```
Counter heads;
```

对象是能够承载数据类型的值的实体。所有对象都有三大重要特性：状态、标识和行为。对象的状态即数据类型中的值。对象的标识能够将一个对象区别于另一个对象。可以认为对象的标识就是它在内存中的位置。对象的行为就是数据类型的操作。数据类型的实现的唯一职责就是维护一个对象的身份，这样用例代码在使用数据类型时只需遵守描述对象行为的API即可，而无需关注对象的表示方法。对象的状态可以为用例代码提供信息，或是产生某种副作用，或是被数据类型的操作所改变。但数据类型的值的表示细节和用例代码是无关的。

引用是访问对象的一种方式。 Java 使用术语**引用类型**以示和原始数据类型（变量和值相关联）的区别。

#### 1.2.1.5 创建对象

每种数据类型的值都存储于一个对象中。要创建（或实例化）一个对象，我们用关键字 new 并紧跟类名以及()（或在括号中指定一系列的参数，如果构造函数需要的话）来触发它的构造函数。构造函数没有返回值，因为它总是返回它的数据类型的对象的引用。每当用例调用了 new()，系统都会：

* 为新的对象分配内存空间；
* 调用构造函数初始化对象中的值；
* 返回该对象的一个引用。

在用例代码中，我们一般都会在一条声明语句中创建一个对象并通过将它和一个变量关联来初始化该变量，和使用原始数据类型时一样。和原始数据类型不同的是，变量关联的是指向对象的引用而非数据类型的值本身。我们可以用同一个类创建无数对象，每个对象都有自己的标识，且所存储的值和另一个相同类型的对象可以相同也可以不同。例如，以下代码中创建了两个不同的 Counter 对象：

```
Counter heads = new Counter("heads");
Counter tails = new Counter("tails");
```

抽象数据类型向用例隐藏了值的表示细节。可以假设每个 Counter 对象中的值是一个 String 类型的名称和一个 int 计数器，但不能编写依赖于任何特定表示方法的代码（即使知道假设是否正确，也许计数器是一个long值）对象的创建过程如图1.2.2所示。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-1697b9c5a4f29eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1。2.1.6 调用实例方法

实例方法的意义在于操作数据类型中的值，因此 Java 语言提供了一种特别的机制来触发实例方法，它突出了实例方法和对象之间的联系。具体来说，我们调用一个实例方法的方式是先写出对象的变量名，紧接着是一个句点，然后是实例方法的名称。实例方法可能会改变数据类型中的值，也可能只是访问数据类型中的值。实例方法拥有我们在1.1.6.3节讨论过的静态方法的所有性质：参数按值传递，方法名可以被重载，方法可以有返回值，它们也许还会产生一些副作用。但它们还有一个特别的性质：方法的每次触发都是和一个对象相关的。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c578001b282d919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

静态方法的主要作用是实现函数；非静态（实例）方法的主要作用是实现数据类型的操作。此外静态方法调用的开头是类名（按习惯为大写），而非静态方法调用的开头总是对象名（按习惯为小写）。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f2319cb2c2a34ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.1.7 使用对象

通过声明语句可以将变量名赋给对象，在代码中，我们不仅可以用该变量创建对象和调用实例方法，也可以像使用整数、浮点数和其他原始数据类型的变量一样使用它。要开发某种给定数据类型的用例，我们需要：

* 声明该类型的变量，以用来引用对象；
* 使用关键字 new 触发能够创建该类型的对象的一个构造函数；
* 使用变量名在语句或表达式中调用实例方法。

#### 1.2.1.8 赋值语句

使用引用类型的赋值语句将会创建该引用的一个副本。赋值语句不会创建新的对象，而只是创建另一个指向某个已经存在的对象而已。这种情况被称为别名：两个变量同时指向同一个对象。别名的效果可能会导致一些莫名奇妙的问题。如果 x 和 y 是原始数据类型的变量，那么赋值语句 x=y 会将y的值复制到x中。对于引用类型，复制的是引用（而非实际的值）。在 Java 中，别名是导致bug的常见原因。

```
Counter c1 = new Counter("ones");
c1.increment();
Counter c2 = c1;
c2.increment();
StdOut.println(c1);
```
打印结果是“2 ones”，这种bug就是因为别名引起的。也就是说改变一个对象的状态将会影响到所有和该对象的别名有关的代码。

#### 1.2.1.9 将对象作为参数

**形参**：方法被调用时需要传递进来的参数。如func(int a)中的a，它只有在func方法被调用时a才有意义，也就是会被分配内存空间，在方法func执行完成后，a的内存空间就会被释放掉，a对象也就被销毁了。

**实参**：方法被调用时传入的实际值。它在方法被调用前就已经被初始化并且在方法被调用时传入。

```
Person per = new Person();
```

实际上，它也是有两个过程：

```
Person per;//定义变量
per = new Person();//赋值
```

在执行 Person per 时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person() 时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。由此可见：对于引用数据类型的对象、数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。

**值传递**：在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内部对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值。

**引用传递**：指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参。在方法体内，形参和实参指向同一块内存地址，因此对形参的操作会影响实参值。

```
// Person 类
public class Person {
  private String name;
  private int age;
  
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
  public int getAge() {
    return age;
  }
  public void setAge(int age) {
    this.age = age;
  }
 }
 
public static void PersonCrossTest(Person person){
  System.out.println("传入的person的name："+person.getName());
  person.setName("我是bhl");
  System.out.println("方法内重新赋值后的name："+person.getName());
}
//测试
public static void main(String[] args) {
  Person p=new Person();
  p.setName("我是fqy");
  p.setAge(45);
  PersonCrossTest(p);
  System.out.println("方法执行后的name："+p.getName());
}
输出结果：
传入的person的name：我是fqy
方法内重新赋值后的name：我是bhl
方法执行后的name：我是bhl
```

[Java中的值传递和地址传递详解](https://blog.csdn.net/bntx2jsqfehy7/article/details/83508006)

#### 1.2.1.10 将对象作为返回值

也可以将对象作为方法的返回值。方法可以将它的参数对象返回，也可以创建一个对象并返回它的引用。这种能力非常重要，因为 Java 中的方法只能有一个返回值，但是有了对象我们的代码实际上就能返回多个值。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-f75ca45c995836b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.1.11 数组也是对象

在 Java中，所有非原始数据类型的值都是对象。也就是说，数组也是对象。和字符串一样， Java 语言对于数组的某些操作有特殊的支持：声明、初始化和索引。和其他对象一样，当我们将数组传递给一个方法或是将一个数组变量放在赋值语句的右侧时，我们都是在创建该数组引用的一个副本，而非数组的副本。对于一般情况，这种效果正是我们所期望的，因为我们期望方法能够重新安排数组的条目并修改数组的内容，如 java.utils.Array.sort() 或表 1.1.10讨论的 shuffle() 方法。

#### 1.2.1.12 对象的数组

数组元素可以是任意类型的数据。我们实现的 main() 方法的 args[] 参数就是一个 String 对象的数组。创建一个对象数组需要以下两个步骤：

* 使用方括号语法调用数组的构造函数创建数组；
* 对于每个数组元素调用它的构造函数创建相应的对象。

在Java中，对象数组就是一个由对象的引用而组成的数组，而非所有对象本身组成的数组。如果对象非常大，那么在移动它们时由于只需要操作引用而非对象本身，这就会大大提高效率；如果对象很小，每次获取信息时都需要通过引用反而会降低效率。

下面这段代码模拟的是掷骰子。它使用了一个 Counter 对象的数组来记录每种可能的值的出现次数。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-257c27bc059073e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

运用**数据抽象的思想**编写代码（定义和使用数据类型，将数据类型的值封装在对象中）的方式成为**面向对象编程**。**数据类型**指的是一组值和一组对值的操作的集合。我们会将数据类型实现在独立的 Java 类模块中并编写它们的用例。对象是能够存储任意该数据类型的值的实体，或数据类型的实例。对象有三大关键性质：状态、标识和行为。

一个数据类型的实现所支持的操作如下：

* **创建对象**（创造它的标识）：使用 new 关键字触发构造函数并创建对象，初始化对象中的值并返回对它的引用。
* **操作对象中的值**（控制对象的行为，可能会改变对象的状态）：使用和对象关联的变量调用实例方法来对对象中的值进行操作
* **操作多个对象**：创建对象的数组，像原始数据类型的值一样将它们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身。

这些能力是这种灵活且应用广泛的现代编程方式的基础，也是我们在本书中对算法研究的基础。


### 1.2.2 抽象数据类型举例

本书中将会用到或开发的所有数据类型可以被分为以下几类：

* java.lang.* 中的标准系统抽象数据类型，可以被任意 Java 程序调用。
* Java标准库中的抽象数据类型，如 java.swt、java.net 和 java.io，它们也可以被任意 Java 程序调用，但需要 import 语句。
* I/O 处理类抽象数据类型，和 StdIn 和 StdOut 类似，允许我们处理多个输入输出流。
* 面向数据类抽象数据类型，它们的主要作用是通过封装数据的表示简化数据的组织和处理。
* 集合类抽象数据类型，它们的主要用途是简化对同一类型的一组数据的操作。
* 面向操作的抽象数据类型。
* 图算法相关的抽象数据类型。

#### 1.2.2.1 几何对象

处理几何对象的程序在自然世界模型、科学计算、电子游戏、电影等许多应用的计算中有着广泛的应用。此类程序的研发已经发展成了**计算机几何学**这门影响深远的研究学科。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-8f0400f029bcf666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-3900c4199f17be3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-10bcb9d3250e2799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Interval2D的测试用例：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-52e747a2c118111f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.2.2 信息处理

无数应用的核心都是组织和处理信息。抽象数据类型是组织信息的一种自然方式。表1。2.6中的两份API也展示了商业应用程序中的一种典型做法。这里的主要思想是定义和真实世界中的物体相对应的对象。一个日期就是一个日、月和年的集合，一笔交易就是一个客户、日期和金额的集合。

**每种数据类型都包含能够创建对象的构造函数和用于访问其中数据的方法**。为了简化用例的代码，我们为每个类型都提供了两个构造函数，一个接受适当类型的数据，另一个则能够解析字符串中的数据。

#### 1.2.2.3 字符串

一个 String 值是一串可以由索引访问的 char 值。String对象拥有很多实例方法。Java 的字符串部分API如下：

```
Public class String
       String() //创建一个空字符串
  int  length() //字符串长度
  int  charAt(int i) // 第i个字符
  int  indexOf(String p) //p第一次出现的位置（如果没有则返回 -1）
  int  indexOf(String p, int i) //p在i个字符后第一次出现的位置（如果没有则返回 -1）
  String concat(String t) // 将t附在该字符串末尾
  String substring(int i, int j) //该字符串的子字符串（第i个字符到第j-1个字符）
  String[] split(String delim) //使用delim分割符切分字符串
  int  compareTo(String t)  // 比较字符串
  boolean  equals(String t) //该字符串的值和t的值是否相同
  int hashCode() //散列值
```

![image.png](https://upload-images.jianshu.io/upload_images/4164292-9884c8f87e0bebc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

split()方法的参数可以是正则表达式。典型的字符串处理代码中split()的参数是“\\s+”，它表示“一个或多个制表符、空格、换行符或回车”。

#### 典型的字符串处理代码：

**1、判断字符串是否是一条回文：**

```
public static boolean isPalindrome(String s) {
  int N = s.length();
  for (int i = 0; i < N/2; i++)
    if (s.charAt(i) != s.charAt(N-1-i))
      return false;
    return true;  
}
```

**2、从一个命令行参数中提取文件名和扩展名：**

```
String s = args[0];
int dot = s.indexOF(".");
String base = s.substring(0, dot);
String extension = s.substring(dot + 1, s.length());
```

**3、打印出标准输入中所有含有通过命令行指定的字符串的行：**

```
String query = args[0];
while (!StdIn.isEmpty())
{
  String s = StdIn.readLine();
  if (s.contains(query))  StdOut.println(s);
}
```

**4、以空白字符为分隔符从StdIn中创建一个字符串数组：**

```
String input = StdIn.readAll();
String[] words = input.split("\\s+");
```

**5、检查一个字符串数组中的元素是否已按照字母表顺序排列：**

```
public boolean isSorted(String[] a)
{
  for (int i = 1; i < a.length; i++)
  {
    if (a[i-1].compareTo(a[i]) > 0)
      return false;
  }
  return true;
}
```

![image.png](https://upload-images.jianshu.io/upload_images/4164292-077486dec9b0b01e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-7431e81cc3e366ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.3 抽象数据类型的实现

![image.png](https://upload-images.jianshu.io/upload_images/4164292-52fb952eda3ded01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在抽象数据类型的实现中，我们会使用 private，也就是使用 Java 语言的机制来保证向使用者隐藏抽象数据类型中的数据表示。**如果某值在初始化之后不应该再被改变，那么需要使用 final关键字修饰**。

#### 1.2.3.2 构造函数

每个 Java 类都至少含有一个构造函数以创建一个对象的标识。构造函数类似于一个静态方法，但它能够直接访问实例变量且没有返回值。一般来说，构造函数的作用是初始化实例变量。每个构造函数都将创建一个对象并向调用者返回一个该对象的引用。构造函数的名称总是和类名相同。我们可以和重载方法一样重载这个名称并定义签名不同的多个构造函数。

如果没有定义构造函数，类将会隐式定义一个默认情况下不接受任何参数的构造函数并将所有实例变量初始化为默认值。原始数字类型的实例变量默认值为0，布尔类型变量为false，引用类型变量默认为null。我们可以在声明语句中初始化这些实例变量并改变这些默认值。

当用例使用关键字 new 时，Java 会自动触发一个构造函数。重载构造函数一般用于将实例变量由默认值初始化为用例提供的值。例如，Counter类型有个接受一个参数的构造函数，它将实例变量 name 初始化为由参数给定的值（实例变量count仍将被初始化为默认值0）

详解构造函数：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-71a25d2188d52987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.3.3 实例方法

实现数据类型的实例方法（即每个对象的行为）的代码和1.1节中实现静态方法（函数）的代码基本相同。实例方法和静态方法只有一点关键的不同：实例方法可以访问并操作实例变量。

每个实例方法都有一个返回值类型、一个签名（它指定了方法名、返回值类型和所有参数变量的名称）和一个主体（它由一系列语句组成，包括一个返回语句来将一个返回类型的值传递给调用者。）

当调用者触发了一个方法时，方法的参数（如果有）均会被初始化为调用者所提供的值，方法的语句被执行，直到得到一个返回值并且将该值返回给调用者。

详解实例方法：

![image.png](https://upload-images.jianshu.io/upload_images/4164292-3e8f902e78fc700b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.3.4 作用域

在实现实例方法的 Java代码中使用了三种变量：参数变量、局部变量、实例变量。

参数变量的作用域是整个方法；局部变量的作用域是当前代码段中它的定义之后的所有语句；实例变量的作用域是整个类。需要注意的是，如果出现二义性，可以使用this.实例变量名来加以区别。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-d32005795152b4f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.3.5 API、用例与实现

我们会按照三步走的方式用抽象数据类型满足用例的需求：

* 定义一份 API：API的作用是将使用和实现分离，以实现模块化编程。
* 用一个 Java 类实现 API 的定义：首先我们选择适当的实例变量，然后再编写构造函数和实例方法。
* 实现多个测试用例来验证前两步做出的设计决定。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-c76940374c5d1268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-74179296724f8b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.4.3 累加器

![image.png](https://upload-images.jianshu.io/upload_images/4164292-41f898471858d784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-89666e3d3a89b5b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 1.2.5 数据类型的设计

抽象数据类型是一种向用例隐藏内部表示的数据类型。这种思想强有力地影响了现代编程。

#### 1.2.5.1 封装

面向对象编程的特征之一就是使用数据类型的实现封装数据，以简化实现和隔离用例开发。封装实现了模块化编程。封装同时也隔离了数据类型的操作。

一个封装的数据类型可以被任意用例使用，因此它扩展了Java 语言。我们所提倡的编程风格是**将大型程序分解为能够独立开发和调试的小型模块。这种方式将修改代码的影响限制在局部区域，改进了我们的软件质量。它也促进了代码的复用，因为我们可以用某种数据类型的新实现代替老的实现来改进它的性能、准确度或是内存消耗**。

在算法和数据结构的学习中，我们总是希望开发出更好的算法，因为只需用抽象数据类型的改进实现替换老的实现即可在不改变任何用例代码的情况下改进所有用例的性能。模块化编程成功的关键在于保持模块之间的独立性。我们坚持将 API 作为用例和实现之间唯一的依赖点来做到这一点。并不需要知道一个数据类型是如何实现的才能使用它，实现数据类型也应该假设使用者除了API之外什么也不知道。封装是获得所有这些优势的关键。

#### 1.2.5.2 设计 API

构建现代软件最重要也最有挑战的一项任务就是设计 API。它需要经验、思考和反复的修改，但设计一份优秀的API所付出的所有时间都能从调试和代码复用所节省的时间中获得回报。

设计API时可以参照“只为用例提供它们所需要的，仅此而已。”这句话。

#### 二分查找 & 面向对象

将二分查找重写为一段面向对象的程序，用于在整数集合中进行查找的一种抽象数据类型。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-e8840e68be2ab5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/4164292-0a40f0c96f74a8d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.5.4 接口继承

Java语言为定义对象之间的关系提供了支持，称为接口。

#### 1.2.5.5 实现继承

Java 还支持另一种继承机制，被称为子类。这种非常强大的技术使程序员不需要重写整个类就能改变它的行为或者为它添加新的功能。它的主要思想是定义一个新类（子类或称为派生类）来继承另一个类（父类或称为基类）的所有实例方法和实例变量。子类包含的方法比父类更多。另外，子类可以重新定义或重写父类的方法。

每个类都是 Java的Object类的子类。这种结构意味着每个类都含有 getClass()、toString()、equals()、hashCode()和另外几个我们不会在本书中用到的方法的实现。实际上，每个类都通过子类继承从Object类中继承了这些方法，因此任何用例都可以在任意对象中调用这些方法。我们通常会重载新类的 toString()、equals()和hashCode()方法。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-91e6f36d807ca661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 1.2.5.7 封装类型

Java提供了一些内置的引用类型，称为封装类型。每种原始数据类型都有一个对应的封装类型：Boolean、Byte、Character、Double、Float、Integer、Long和Short分别对应着 boolean、byte、char、double、float、int、long和short。这些类主要由类似于parseInt()这样的静态方法组成。但它们也含有继承得到的实例方法 toString()、compareTo()、equals()和hashCode()。在需要的时候Java会自动将原始数据类型转换为封装类型。例如，当一个int值需要和一个String连接时，它的类型会被转换为Integer并触发 toString()方法。

#### 1.2.5.8 等价性

![image.png](https://upload-images.jianshu.io/upload_images/4164292-cab0ce0fde145e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 1.2.5.9 内存管理

Java最重要的一个特性就是自动内存管理。它通过记录孤儿对象并将它们的内存释放到内存池中将程序员从管理内存的责任中解放出来。这种回收内存的方式叫做垃圾回收。

#### 1.2。5.10 不可变性

Java语言通过 final 修饰符来强制保证不可变性。当你将一个变量声明为 final 时，也就保证了只会对它赋值一次，可以用赋值语句，也可以用构造函数。试图改变final 变量的值的代码将会产生一个编译时错误。需要注意的是，final只能用来保证原始数据类型的实例变量的不可变性，而无法用于引用类型的变量。

String对象是不可变的，而Java数组是可变的。当我们希望使用可变字符串时可以使用 StringBuilder类，当希望使用不可变数组时可以使用 Vector 类。

##### 1.2.5.11 契约式设计

* 异常（Exception），一般用于处理不受我们控制的不可预见的错误。
* 断言（Assertion），验证我们在代码中做出的一些假设。断言的作用是调试，程序在正常操作中不应该依赖断言。











