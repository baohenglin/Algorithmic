## 链表

想要写好链表代码并不是件容易的事儿，尤其是那些复杂的链表操作，比如链表反转、有序链表合并等。为什么链表代码这么难写？究竟怎样才能比较轻松地写出正确的链表代码呢？下面总结了几个写链表代码的技巧。

### 技巧一：理解指针或引用的含义

要想写好链表代码，首先要**深入理解指针**。有些编程语言有“指针”的概念，比如 C 语言；有些编程语言则没有指针，取而代之的是“引用”，比如 Java、Python、Objective-C。不管“指针”还是“引用”，实际上它们的本质是一样的，都是**存储所指对象的内存地址**。

对指针的理解：**将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针。也就是说，指针中存储了这个变量的内存地址，指针指向了此变量**（通过指针就能找到该变量）。

```
//p结点中的 next 指针存储了 q 结点的内存地址。
p->next = q;
```

### 技巧二：警惕指针丢失和内存泄漏

比如我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果按照下面两行代码实现，那么就会发生指针丢失和内存泄漏。

```
p->next = x; //将p结点的next指针指向x结点
x->next = p->next; //将x结点的next指针指向b结点
```

为什么出现了指针丢失、内存泄漏的问题了呢？因为 p->next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向了结点 x。第 2 行代码相当于将 x 赋值给 x->next，自已指向了自身。因此整个链表也就断裂，从结点 b 往后的所有结点都无法访问了。

对于某些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄漏。所以我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。

正确实现插入x结点的代码如下：

```
x->next = b;
p->next = x;
```

同理，删除链表结点时，也一定要记得手动释放内存空间，否则也会造成内存泄漏。


### 技巧三：利用哨兵简化实现难度

#### 单链表插入操作

在结点 p 后面插入一个新的结点，代码如下：

```
new_node->next = p->next;
p->next = new_node;
```

但是，当我们向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面的特殊处理：

```
if (head == null) {
  head = new_node
}
```

#### 单链表删除操作

删除结点 p 的后继结点：

```
p->next = p->next->next;
```

但是如果要删除链表中的最后一个结点，那就需要进行以下特殊处理：

```
if (head->next == null) {
  head = null;
}
```

从上面的分析可以看出，针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，而且也容易因为考虑不全而出错，那么如何来解决这个问题呢？

这个时候，“哨兵”就要登场了。head=null 表示链表中没有结点了（空链表），其中 head 表示头结点指针，指向链表中的第一个结点。

**如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点**。我们把这种有哨兵结点的链表叫**带头链表**。把没有哨兵结点的链表叫作**不带头链表**。哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。

实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

### 技巧四：重点留意边界条件处理

### 技巧五：举例画图，辅助思考

### 技巧六：多写多练，没有捷径
